# Codivio 前端技术方案

## 🎯 技术栈选择

基于现代前端开发最佳实践，构建高性能、可维护的协作编辑器前端应用。

### 核心技术栈
- 🚀 **Vue 3** - 渐进式框架，Composition API
- 📝 **TypeScript** - 类型安全，代码质量保证
- ⚡ **Vite** - 现代构建工具，开发体验优秀
- 🎨 **Element Plus** - 企业级UI组件库
- 📦 **Pinia** - 现代状态管理方案
- 🔗 **Monaco Editor** - VS Code同款代码编辑器
- 🌐 **WebSocket** - 实时通信协议

## 📁 项目结构设计

```
frontend/
├── public/                    # 静态资源
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── assets/               # 静态资源
│   │   ├── styles/          # 全局样式
│   │   ├── images/          # 图片资源
│   │   └── icons/           # 图标资源
│   ├── components/          # 通用组件
│   │   ├── common/          # 基础组件
│   │   ├── editor/          # 编辑器组件
│   │   └── collaboration/   # 协作组件
│   ├── views/               # 页面组件
│   │   ├── auth/           # 认证页面
│   │   ├── dashboard/      # 工作台
│   │   ├── project/        # 项目管理
│   │   └── editor/         # 编辑器页面
│   ├── stores/             # 状态管理
│   │   ├── auth.ts
│   │   ├── project.ts
│   │   └── collaboration.ts
│   ├── services/           # API服务
│   │   ├── api.ts
│   │   ├── websocket.ts
│   │   └── collaboration.ts
│   ├── utils/              # 工具函数
│   │   ├── request.ts
│   │   ├── storage.ts
│   │   └── editor.ts
│   ├── types/              # TypeScript类型定义
│   │   ├── api.ts
│   │   ├── user.ts
│   │   └── collaboration.ts
│   ├── router/             # 路由配置
│   │   └── index.ts
│   ├── plugins/            # 插件配置
│   │   └── element-plus.ts
│   ├── App.vue
│   └── main.ts
├── package.json
├── vite.config.ts
├── tsconfig.json
└── Dockerfile
```

---

## 🎨 UI/UX 设计方案

### 设计系统

#### 色彩方案
```scss
// 主色调
$primary-color: #007bff;      // 蓝色 - 主要操作
$success-color: #28a745;      // 绿色 - 成功状态
$warning-color: #ffc107;      // 黄色 - 警告提示
$danger-color: #dc3545;       // 红色 - 危险操作
$info-color: #17a2b8;         // 青色 - 信息提示

// 协作色彩（用户标识）
$collaboration-colors: (
  user1: #ff6b6b,  // 红色
  user2: #4ecdc4,  // 青色
  user3: #45b7d1,  // 蓝色
  user4: #96ceb4,  // 绿色
  user5: #feca57,  // 黄色
  user6: #ff9ff3,  // 粉色
  user7: #54a0ff,  // 天蓝色
  user8: #5f27cd   // 紫色
);

// 暗色主题
$dark-bg: #1e1e1e;
$dark-surface: #252526;
$dark-border: #3e3e42;
$dark-text: #cccccc;
```

#### 布局系统
```vue
<!-- 主布局组件 -->
<template>
  <div class="app-layout">
    <!-- 顶部导航栏 -->
    <AppHeader />
    
    <!-- 主内容区 -->
    <div class="app-main">
      <!-- 侧边栏 -->
      <AppSidebar v-if="showSidebar" />
      
      <!-- 内容区域 -->
      <div class="app-content">
        <router-view />
      </div>
    </div>
    
    <!-- 状态栏 -->
    <AppStatusBar />
  </div>
</template>

<style scoped>
.app-layout {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-main {
  flex: 1;
  display: flex;
  overflow: hidden;
}

.app-content {
  flex: 1;
  overflow: auto;
}
</style>
```

---

## 🔧 核心功能实现

### 1. 用户认证系统

#### 登录组件
```vue
<!-- views/auth/Login.vue -->
<template>
  <div class="login-container">
    <el-card class="login-card">
      <h2>登录 Codivio</h2>
      
      <el-form :model="loginForm" :rules="rules" ref="formRef">
        <el-form-item prop="username">
          <el-input
            v-model="loginForm.username"
            placeholder="用户名"
            prefix-icon="User"
          />
        </el-form-item>
        
        <el-form-item prop="password">
          <el-input
            v-model="loginForm.password"
            type="password"
            placeholder="密码"
            prefix-icon="Lock"
            show-password
          />
        </el-form-item>
        
        <el-form-item>
          <el-button
            type="primary"
            :loading="loading"
            @click="handleLogin"
            class="login-btn"
          >
            登录
          </el-button>
        </el-form-item>
      </el-form>
      
      <div class="login-footer">
        <router-link to="/register">还没有账号？立即注册</router-link>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import { reactive, ref } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessage } from 'element-plus'
import { useAuthStore } from '@/stores/auth'

const router = useRouter()
const authStore = useAuthStore()

const loading = ref(false)
const formRef = ref()

const loginForm = reactive({
  username: '',
  password: ''
})

const rules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' }
  ]
}

const handleLogin = async () => {
  if (!formRef.value) return
  
  await formRef.value.validate(async (valid: boolean) => {
    if (!valid) return
    
    loading.value = true
    try {
      await authStore.login(loginForm)
      ElMessage.success('登录成功')
      router.push('/dashboard')
    } catch (error: any) {
      ElMessage.error(error.message || '登录失败')
    } finally {
      loading.value = false
    }
  })
}
</script>
```

#### 认证状态管理
```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { authApi } from '@/services/api'
import { getToken, setToken, removeToken } from '@/utils/storage'
import type { User, LoginParams } from '@/types/user'

export const useAuthStore = defineStore('auth', () => {
  const token = ref<string>(getToken() || '')
  const user = ref<User | null>(null)
  
  const isAuthenticated = computed(() => !!token.value)
  
  // 登录
  const login = async (params: LoginParams) => {
    const response = await authApi.login(params)
    const { accessToken, user: userInfo } = response.data
    
    token.value = accessToken
    user.value = userInfo
    setToken(accessToken)
  }
  
  // 登出
  const logout = async () => {
    try {
      await authApi.logout()
    } catch (error) {
      console.error('登出请求失败:', error)
    } finally {
      token.value = ''
      user.value = null
      removeToken()
    }
  }
  
  // 获取用户信息
  const fetchUserInfo = async () => {
    if (!token.value) return
    
    try {
      const response = await authApi.getUserInfo()
      user.value = response.data
    } catch (error) {
      // Token可能已过期，清除本地状态
      logout()
      throw error
    }
  }
  
  return {
    token,
    user,
    isAuthenticated,
    login,
    logout,
    fetchUserInfo
  }
})
```

### 2. 项目管理界面

#### 项目列表组件
```vue
<!-- views/dashboard/ProjectList.vue -->
<template>
  <div class="project-list">
    <div class="project-header">
      <h2>我的项目</h2>
      <el-button type="primary" @click="showCreateDialog = true">
        <el-icon><Plus /></el-icon>
        新建项目
      </el-button>
    </div>
    
    <!-- 项目卡片网格 -->
    <div class="project-grid" v-loading="loading">
      <div
        v-for="project in projects"
        :key="project.id"
        class="project-card"
        @click="openProject(project.id)"
      >
        <div class="project-info">
          <h3>{{ project.name }}</h3>
          <p class="project-desc">{{ project.description }}</p>
          
          <div class="project-meta">
            <el-tag :type="getLanguageType(project.language)">
              {{ project.language }}
            </el-tag>
            <span class="last-activity">
              {{ formatTime(project.lastActivity) }}
            </span>
          </div>
          
          <div class="project-members">
            <el-avatar-group :max="4">
              <el-avatar
                v-for="member in project.members"
                :key="member.userId"
                :src="member.avatar"
                :title="member.nickname"
                size="small"
              />
            </el-avatar-group>
            <span v-if="project.memberCount > 4" class="member-count">
              +{{ project.memberCount - 4 }}
            </span>
          </div>
        </div>
        
        <div class="project-actions">
          <el-dropdown @command="handleProjectAction">
            <el-button text>
              <el-icon><MoreFilled /></el-icon>
            </el-button>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item :command="{action: 'edit', project}">
                  编辑
                </el-dropdown-item>
                <el-dropdown-item :command="{action: 'members', project}">
                  成员管理
                </el-dropdown-item>
                <el-dropdown-item :command="{action: 'delete', project}" divided>
                  删除
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>
    </div>
    
    <!-- 创建项目对话框 -->
    <CreateProjectDialog
      v-model="showCreateDialog"
      @created="handleProjectCreated"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessage, ElMessageBox } from 'element-plus'
import { useProjectStore } from '@/stores/project'
import { formatRelativeTime } from '@/utils/time'
import type { Project } from '@/types/project'

const router = useRouter()
const projectStore = useProjectStore()

const loading = ref(false)
const showCreateDialog = ref(false)
const projects = ref<Project[]>([])

const getLanguageType = (language: string) => {
  const types: Record<string, string> = {
    javascript: 'warning',
    typescript: 'primary',
    python: 'success',
    java: 'danger'
  }
  return types[language] || 'info'
}

const formatTime = (time: string) => {
  return formatRelativeTime(new Date(time))
}

const openProject = (projectId: string) => {
  router.push(`/project/${projectId}`)
}

const handleProjectAction = async ({ action, project }: any) => {
  switch (action) {
    case 'edit':
      // 编辑项目逻辑
      break
    case 'members':
      // 成员管理逻辑
      break
    case 'delete':
      await handleDeleteProject(project)
      break
  }
}

const handleDeleteProject = async (project: Project) => {
  try {
    await ElMessageBox.confirm(
      `确定要删除项目 "${project.name}" 吗？此操作不可恢复。`,
      '删除确认',
      { type: 'warning' }
    )
    
    await projectStore.deleteProject(project.id)
    ElMessage.success('项目删除成功')
    await loadProjects()
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error(error.message || '删除失败')
    }
  }
}

const handleProjectCreated = () => {
  loadProjects()
}

const loadProjects = async () => {
  loading.value = true
  try {
    projects.value = await projectStore.fetchProjects()
  } catch (error: any) {
    ElMessage.error(error.message || '加载项目列表失败')
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  loadProjects()
})
</script>

<style scoped>
.project-list {
  padding: 24px;
}

.project-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.project-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 20px;
}

.project-card {
  border: 1px solid var(--el-border-color);
  border-radius: 8px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.project-card:hover {
  border-color: var(--el-color-primary);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.project-info h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  font-weight: 600;
}

.project-desc {
  color: var(--el-text-color-regular);
  margin: 0 0 16px 0;
  line-height: 1.4;
}

.project-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.last-activity {
  font-size: 12px;
  color: var(--el-text-color-secondary);
}

.project-members {
  display: flex;
  align-items: center;
  gap: 8px;
}

.member-count {
  font-size: 12px;
  color: var(--el-text-color-secondary);
}

.project-actions {
  position: absolute;
  top: 16px;
  right: 16px;
}
</style>
```

### 3. 实时协作编辑器

#### Monaco 编辑器组件
```vue
<!-- components/editor/MonacoEditor.vue -->
<template>
  <div class="monaco-editor-container">
    <!-- 协作用户状态栏 -->
    <div class="collaboration-bar" v-if="activeUsers.length > 0">
      <div class="active-users">
        <span class="users-label">在线用户:</span>
        <div class="user-avatars">
          <div
            v-for="user in activeUsers"
            :key="user.userId"
            class="user-avatar"
            :style="{ borderColor: user.cursorColor }"
            :title="user.nickname"
          >
            <img :src="user.avatar" :alt="user.nickname" />
          </div>
        </div>
      </div>
      
      <div class="connection-status">
        <el-icon :class="connectionStatusClass">
          <Connection v-if="isConnected" />
          <Close v-else />
        </el-icon>
        <span>{{ connectionStatusText }}</span>
      </div>
    </div>
    
    <!-- 编辑器容器 -->
    <div ref="editorContainer" class="editor-container"></div>
    
    <!-- 用户光标显示 -->
    <div class="cursors-overlay">
      <div
        v-for="cursor in remoteCursors"
        :key="cursor.userId"
        class="remote-cursor"
        :style="getCursorStyle(cursor)"
      >
        <div 
          class="cursor-line"
          :style="{ backgroundColor: cursor.color }"
        ></div>
        <div 
          class="cursor-label"
          :style="{ backgroundColor: cursor.color }"
        >
          {{ cursor.nickname }}
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue'
import * as monaco from 'monaco-editor'
import { useCollaborationStore } from '@/stores/collaboration'
import { useWebSocket } from '@/services/websocket'
import type { RemoteCursor, CollaborationUser } from '@/types/collaboration'

interface Props {
  modelValue: string
  language: string
  projectId: string
  filePath: string
  readonly?: boolean
}

interface Emits {
  (e: 'update:modelValue', value: string): void
  (e: 'change', value: string): void
}

const props = withDefaults(defineProps<Props>(), {
  readonly: false
})

const emit = defineEmits<Emits>()

const collaborationStore = useCollaborationStore()
const { connect, disconnect, sendOperation, isConnected } = useWebSocket()

const editorContainer = ref<HTMLDivElement>()
const editor = ref<monaco.editor.IStandaloneCodeEditor>()
const activeUsers = ref<CollaborationUser[]>([])
const remoteCursors = ref<RemoteCursor[]>([])

let isLocalChange = false

const connectionStatusClass = computed(() => ({
  'status-connected': isConnected.value,
  'status-disconnected': !isConnected.value
}))

const connectionStatusText = computed(() => 
  isConnected.value ? '已连接' : '连接断开'
)

// 初始化编辑器
const initEditor = () => {
  if (!editorContainer.value) return
  
  editor.value = monaco.editor.create(editorContainer.value, {
    value: props.modelValue,
    language: props.language,
    theme: 'vs-dark',
    readOnly: props.readonly,
    fontSize: 14,
    lineNumbers: 'on',
    minimap: { enabled: true },
    scrollBeyondLastLine: false,
    automaticLayout: true,
    wordWrap: 'on'
  })
  
  // 监听内容变化
  editor.value.onDidChangeModelContent((e) => {
    if (isLocalChange) return
    
    const value = editor.value?.getValue() || ''
    emit('update:modelValue', value)
    emit('change', value)
    
    // 发送操作到服务器
    for (const change of e.changes) {
      sendOperation({
        type: 'insert',
        position: change.rangeOffset,
        text: change.text,
        length: change.text.length
      })
    }
  })
  
  // 监听光标位置变化
  editor.value.onDidChangeCursorPosition((e) => {
    collaborationStore.updateCursorPosition({
      line: e.position.lineNumber,
      column: e.position.column
    })
  })
  
  // 监听选择变化
  editor.value.onDidChangeCursorSelection((e) => {
    collaborationStore.updateSelection({
      startLine: e.selection.startLineNumber,
      startColumn: e.selection.startColumn,
      endLine: e.selection.endLineNumber,
      endColumn: e.selection.endColumn
    })
  })
}

// 应用远程操作
const applyRemoteOperation = (operation: any) => {
  if (!editor.value) return
  
  isLocalChange = true
  
  try {
    const model = editor.value.getModel()
    if (!model) return
    
    const position = model.getPositionAt(operation.position)
    
    switch (operation.type) {
      case 'insert':
        model.applyEdits([{
          range: new monaco.Range(
            position.lineNumber,
            position.column,
            position.lineNumber,
            position.column
          ),
          text: operation.text
        }])
        break
        
      case 'delete':
        const endPosition = model.getPositionAt(operation.position + operation.length)
        model.applyEdits([{
          range: new monaco.Range(
            position.lineNumber,
            position.column,
            endPosition.lineNumber,
            endPosition.column
          ),
          text: ''
        }])
        break
    }
  } finally {
    isLocalChange = false
  }
}

// 获取光标样式
const getCursorStyle = (cursor: RemoteCursor) => {
  if (!editor.value) return {}
  
  const position = new monaco.Position(cursor.line, cursor.column)
  const coords = editor.value.getScrolledVisiblePosition(position)
  
  if (!coords) return { display: 'none' }
  
  return {
    left: `${coords.left}px`,
    top: `${coords.top}px`,
    display: 'block'
  }
}

// 加入协作房间
const joinCollaboration = async () => {
  try {
    await connect(props.projectId, props.filePath)
    
    // 监听协作事件
    collaborationStore.$subscribe((mutation, state) => {
      activeUsers.value = state.activeUsers
      remoteCursors.value = state.remoteCursors
    })
    
    // 监听远程操作
    collaborationStore.onRemoteOperation(applyRemoteOperation)
    
  } catch (error) {
    console.error('加入协作失败:', error)
  }
}

// 离开协作房间
const leaveCollaboration = () => {
  disconnect()
}

// 监听内容变化
watch(() => props.modelValue, (newValue) => {
  if (!editor.value || isLocalChange) return
  
  const currentValue = editor.value.getValue()
  if (currentValue !== newValue) {
    isLocalChange = true
    editor.value.setValue(newValue)
    isLocalChange = false
  }
})

// 监听语言变化
watch(() => props.language, (newLanguage) => {
  if (!editor.value) return
  monaco.editor.setModelLanguage(editor.value.getModel()!, newLanguage)
})

onMounted(() => {
  initEditor()
  joinCollaboration()
})

onUnmounted(() => {
  leaveCollaboration()
  editor.value?.dispose()
})
</script>

<style scoped>
.monaco-editor-container {
  position: relative;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.collaboration-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background: var(--el-bg-color-page);
  border-bottom: 1px solid var(--el-border-color);
}

.active-users {
  display: flex;
  align-items: center;
  gap: 12px;
}

.users-label {
  font-size: 12px;
  color: var(--el-text-color-secondary);
}

.user-avatars {
  display: flex;
  gap: 4px;
}

.user-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid;
  overflow: hidden;
}

.user-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.status-connected {
  color: var(--el-color-success);
}

.status-disconnected {
  color: var(--el-color-danger);
}

.editor-container {
  flex: 1;
  min-height: 0;
}

.cursors-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 10;
}

.remote-cursor {
  position: absolute;
  pointer-events: none;
}

.cursor-line {
  width: 2px;
  height: 20px;
  animation: blink 1s infinite;
}

.cursor-label {
  position: absolute;
  top: -20px;
  left: 0;
  padding: 2px 6px;
  font-size: 11px;
  color: white;
  border-radius: 3px;
  white-space: nowrap;
  opacity: 0.9;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}
</style>
```

### 4. WebSocket 实时通信

#### WebSocket 服务
```typescript
// services/websocket.ts
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import { useAuthStore } from '@/stores/auth'
import { useCollaborationStore } from '@/stores/collaboration'
import type { OperationMessage, WebSocketMessage } from '@/types/collaboration'

class WebSocketService {
  private ws: WebSocket | null = null
  private reconnectTimer: number | null = null
  private heartbeatTimer: number | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  public isConnected = ref(false)
  public isConnecting = ref(false)
  
  constructor() {
    this.setupEventListeners()
  }
  
  // 连接WebSocket
  async connect(projectId: string, filePath: string): Promise<void> {
    if (this.ws?.readyState === WebSocket.OPEN) {
      return Promise.resolve()
    }
    
    return new Promise((resolve, reject) => {
      try {
        const authStore = useAuthStore()
        const wsUrl = `${import.meta.env.VITE_WS_URL}/ws/editor`
        
        this.ws = new WebSocket(wsUrl)
        this.isConnecting.value = true
        
        this.ws.onopen = () => {
          console.log('WebSocket连接已建立')
          this.isConnected.value = true
          this.isConnecting.value = false
          this.reconnectAttempts = 0
          
          // 发送认证消息
          this.sendMessage({
            type: 'auth',
            data: { token: authStore.token }
          })
          
          // 加入文档协作房间
          this.sendMessage({
            type: 'join-document',
            data: { projectId, filePath }
          })
          
          this.startHeartbeat()
          resolve()
        }
        
        this.ws.onmessage = (event) => {
          this.handleMessage(JSON.parse(event.data))
        }
        
        this.ws.onclose = (event) => {
          console.log('WebSocket连接已关闭', event)
          this.isConnected.value = false
          this.isConnecting.value = false
          this.stopHeartbeat()
          
          if (!event.wasClean && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.scheduleReconnect(projectId, filePath)
          }
        }
        
        this.ws.onerror = (error) => {
          console.error('WebSocket错误:', error)
          this.isConnecting.value = false
          reject(new Error('WebSocket连接失败'))
        }
        
      } catch (error) {
        this.isConnecting.value = false
        reject(error)
      }
    })
  }
  
  // 断开连接
  disconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
    
    this.stopHeartbeat()
    
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect')
      this.ws = null
    }
    
    this.isConnected.value = false
    this.isConnecting.value = false
  }
  
  // 发送操作
  sendOperation(operation: OperationMessage): void {
    this.sendMessage({
      type: 'operation',
      data: operation
    })
  }
  
  // 发送光标位置
  sendCursorPosition(position: { line: number; column: number }): void {
    this.sendMessage({
      type: 'cursor-update',
      data: position
    })
  }
  
  // 发送消息
  private sendMessage(message: WebSocketMessage): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message))
    } else {
      console.warn('WebSocket未连接，无法发送消息')
    }
  }
  
  // 处理接收到的消息
  private handleMessage(message: WebSocketMessage): void {
    const collaborationStore = useCollaborationStore()
    
    switch (message.type) {
      case 'document-joined':
        collaborationStore.handleDocumentJoined(message.data)
        break
        
      case 'operation':
        collaborationStore.handleRemoteOperation(message.data)
        break
        
      case 'cursor-update':
        collaborationStore.handleCursorUpdate(message.data)
        break
        
      case 'user-joined':
        collaborationStore.handleUserJoined(message.data)
        ElMessage.success(`${message.data.nickname} 加入了协作`)
        break
        
      case 'user-left':
        collaborationStore.handleUserLeft(message.data)
        ElMessage.info(`${message.data.nickname} 离开了协作`)
        break
        
      case 'error':
        console.error('服务器错误:', message.data)
        ElMessage.error(message.data.message || '协作服务错误')
        break
        
      case 'pong':
        // 心跳响应，忽略
        break
        
      default:
        console.warn('未知消息类型:', message.type)
    }
  }
  
  // 设置事件监听器
  private setupEventListeners(): void {
    // 页面可见性变化
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.stopHeartbeat()
      } else if (this.isConnected.value) {
        this.startHeartbeat()
      }
    })
    
    // 页面卸载
    window.addEventListener('beforeunload', () => {
      this.disconnect()
    })
  }
  
  // 开始心跳
  private startHeartbeat(): void {
    this.stopHeartbeat()
    this.heartbeatTimer = window.setInterval(() => {
      this.sendMessage({ type: 'ping', data: {} })
    }, 30000) // 30秒心跳
  }
  
  // 停止心跳
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }
  
  // 计划重连
  private scheduleReconnect(projectId: string, filePath: string): void {
    if (this.reconnectTimer) return
    
    this.reconnectAttempts++
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)
    
    console.log(`${delay}ms后尝试第${this.reconnectAttempts}次重连`)
    
    this.reconnectTimer = window.setTimeout(() => {
      this.reconnectTimer = null
      this.connect(projectId, filePath).catch(console.error)
    }, delay)
  }
}

// 导出单例
export const wsService = new WebSocketService()

// 组合式API
export function useWebSocket() {
  return {
    connect: wsService.connect.bind(wsService),
    disconnect: wsService.disconnect.bind(wsService),
    sendOperation: wsService.sendOperation.bind(wsService),
    sendCursorPosition: wsService.sendCursorPosition.bind(wsService),
    isConnected: computed(() => wsService.isConnected.value),
    isConnecting: computed(() => wsService.isConnecting.value)
  }
}
```

---

## 🎯 状态管理方案

### 协作状态管理
```typescript
// stores/collaboration.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { 
  CollaborationUser, 
  RemoteCursor, 
  OperationMessage,
  DocumentState
} from '@/types/collaboration'

export const useCollaborationStore = defineStore('collaboration', () => {
  const documentState = ref<DocumentState | null>(null)
  const activeUsers = ref<CollaborationUser[]>([])
  const remoteCursors = ref<RemoteCursor[]>([])
  const operationQueue = ref<OperationMessage[]>([])
  
  const currentUser = computed(() => {
    const authStore = useAuthStore()
    return activeUsers.value.find(user => user.userId === authStore.user?.id)
  })
  
  const otherUsers = computed(() => {
    const authStore = useAuthStore()
    return activeUsers.value.filter(user => user.userId !== authStore.user?.id)
  })
  
  // 处理文档加入
  const handleDocumentJoined = (data: any) => {
    documentState.value = {
      documentId: data.documentId,
      content: data.content,
      version: data.version
    }
    
    activeUsers.value = data.activeUsers || []
    remoteCursors.value = []
  }
  
  // 处理远程操作
  const handleRemoteOperation = (operation: OperationMessage) => {
    // 应用操作转换算法
    const transformedOperation = transformOperation(operation)
    
    // 触发操作事件
    operationCallbacks.forEach(callback => callback(transformedOperation))
    
    // 更新文档版本
    if (documentState.value) {
      documentState.value.version++
    }
  }
  
  // 处理光标更新
  const handleCursorUpdate = (data: any) => {
    const existingCursor = remoteCursors.value.find(
      cursor => cursor.userId === data.userId
    )
    
    if (existingCursor) {
      Object.assign(existingCursor, data)
    } else {
      const user = activeUsers.value.find(u => u.userId === data.userId)
      if (user) {
        remoteCursors.value.push({
          userId: data.userId,
          nickname: user.nickname,
          color: user.cursorColor,
          line: data.line,
          column: data.column
        })
      }
    }
  }
  
  // 处理用户加入
  const handleUserJoined = (user: CollaborationUser) => {
    const existingIndex = activeUsers.value.findIndex(
      u => u.userId === user.userId
    )
    
    if (existingIndex >= 0) {
      activeUsers.value[existingIndex] = user
    } else {
      activeUsers.value.push(user)
    }
  }
  
  // 处理用户离开
  const handleUserLeft = (data: { userId: string }) => {
    activeUsers.value = activeUsers.value.filter(
      user => user.userId !== data.userId
    )
    
    remoteCursors.value = remoteCursors.value.filter(
      cursor => cursor.userId !== data.userId
    )
  }
  
  // 更新光标位置
  const updateCursorPosition = (position: { line: number; column: number }) => {
    wsService.sendCursorPosition(position)
  }
  
  // 更新选择区域
  const updateSelection = (selection: any) => {
    // 发送选择区域更新
    wsService.sendMessage({
      type: 'selection-update',
      data: selection
    })
  }
  
  // 操作转换算法
  const transformOperation = (operation: OperationMessage): OperationMessage => {
    // 简化的OT算法实现
    // 在实际项目中，这里需要更复杂的转换逻辑
    
    let transformedOperation = { ...operation }
    
    // 对队列中的操作进行转换
    for (const queuedOp of operationQueue.value) {
      if (queuedOp.timestamp < operation.timestamp) {
        transformedOperation = applyTransformation(transformedOperation, queuedOp)
      }
    }
    
    return transformedOperation
  }
  
  // 应用操作转换
  const applyTransformation = (op1: OperationMessage, op2: OperationMessage): OperationMessage => {
    // 插入-插入转换
    if (op1.type === 'insert' && op2.type === 'insert') {
      if (op2.position <= op1.position) {
        return {
          ...op1,
          position: op1.position + op2.text.length
        }
      }
    }
    
    // 删除-插入转换
    if (op1.type === 'insert' && op2.type === 'delete') {
      if (op2.position <= op1.position) {
        return {
          ...op1,
          position: Math.max(op1.position - op2.length, op2.position)
        }
      }
    }
    
    return op1
  }
  
  // 操作回调
  const operationCallbacks = new Set<(operation: OperationMessage) => void>()
  
  const onRemoteOperation = (callback: (operation: OperationMessage) => void) => {
    operationCallbacks.add(callback)
    return () => operationCallbacks.delete(callback)
  }
  
  // 清理状态
  const cleanup = () => {
    documentState.value = null
    activeUsers.value = []
    remoteCursors.value = []
    operationQueue.value = []
    operationCallbacks.clear()
  }
  
  return {
    documentState,
    activeUsers,
    remoteCursors,
    currentUser,
    otherUsers,
    handleDocumentJoined,
    handleRemoteOperation,
    handleCursorUpdate,
    handleUserJoined,
    handleUserLeft,
    updateCursorPosition,
    updateSelection,
    onRemoteOperation,
    cleanup
  }
})
```

---

## 🔧 工程化配置

### Vite 配置
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
      imports: ['vue', 'vue-router', 'pinia']
    }),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/assets/styles/variables.scss";`
      }
    }
  },
  
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      },
      '/ws': {
        target: 'ws://localhost:8083',
        ws: true,
        changeOrigin: true
      }
    }
  },
  
  build: {
    target: 'es2015',
    outDir: 'dist',
    sourcemap: false,
    rollupOptions: {
      output: {
        manualChunks: {
          vue: ['vue', 'vue-router', 'pinia'],
          element: ['element-plus'],
          monaco: ['monaco-editor']
        }
      }
    }
  }
})
```

### TypeScript 配置
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

## 🎯 面试准备要点

### 💡 前端技术亮点

1. **现代前端架构** - Vue 3 + TypeScript + Vite 全家桶
2. **实时协作编辑器** - Monaco Editor + WebSocket + OT算法
3. **状态管理** - Pinia模块化状态管理
4. **工程化完善** - 自动导入、组件库集成、代码分割
5. **TypeScript全覆盖** - 类型安全，开发体验优秀

### 🎯 常见面试问题

#### 1. "为什么选择Vue 3而不是React？"
```yaml
回答要点:
  - 学习成本低，渐进式框架易上手
  - Composition API提供更好的逻辑复用
  - 模板语法更接近HTML，开发效率高
  - TypeScript支持优秀，类型推导强
  - 生态成熟，Element Plus等UI库完善
```

#### 2. "实时协作的技术难点是什么？"
```yaml
回答要点:
  - 操作转换算法，解决并发编辑冲突
  - WebSocket连接管理，断线重连机制
  - 光标位置同步，多用户状态展示
  - 性能优化，大文档编辑流畅性
  - 数据一致性，确保所有用户看到相同内容
```

#### 3. "如何优化大型单页应用的性能？"
```yaml
回答要点:
  - 代码分割，按路由和组件懒加载
  - 组件缓存，keep-alive和v-memo
  - 虚拟滚动，处理大量数据展示
  - 防抖节流，优化用户输入响应
  - CDN资源，静态资源加速
```

#### 4. "状态管理方案如何选择？"
```yaml
回答要点:
  - 小项目用Provide/Inject或Composables
  - 中大型项目用Pinia，模块化管理
  - 跨组件通信用事件总线或状态库
  - 服务端状态用专门的库如TanStack Query
  - 本地状态优先，避免过度集中化
```

### 🚀 技术扩展思考

当面试官问"如何支持更大规模的前端应用？"

```yaml
架构升级:
  - 微前端架构，模块独立开发部署
  - 组件库抽离，统一设计系统
  - 工程化升级，Monorepo管理多项目

性能优化:
  - SSR/SSG，首屏渲染优化
  - Service Worker，离线缓存
  - Web Workers，计算密集任务

开发体验:
  - 可视化搭建，低代码平台
  - 自动化测试，单元测试+E2E
  - CI/CD集成，自动化部署
```