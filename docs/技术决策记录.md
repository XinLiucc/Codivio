# Codivio 技术决策记录 (ADR)

## 📋 概述

本文档记录了 Codivio 项目中所有重要的技术决策过程、理由分析和权衡考量。每个决策都采用 **ADR(Architecture Decision Record)** 格式，确保决策过程的透明性和可追溯性。

### 🎯 决策原则
- **技术可行性** - 技术方案的成熟度和可实现性
- **性能要求** - 满足实时协作的性能需求
- **开发效率** - 团队技术栈匹配度和开发速度
- **可维护性** - 代码质量和长期维护成本
- **学习价值** - 对技术成长和求职的帮助

---

## ADR-001: 总体技术栈选择

**日期**: 2024-08-14  
**状态**: ✅ 已采纳  
**决策者**: 架构团队  

### 🎯 决策
选择 **Spring Boot 3.x + Vue 3 + MySQL + Redis** 作为核心技术栈

### 📊 技术栈详细配置

#### 后端技术栈
```yaml
核心框架: Spring Boot 3.2+
编程语言: Java 17
Web框架: Spring MVC + Spring WebFlux (WebSocket)
安全框架: Spring Security + JWT
数据库: MySQL 8.0 (主数据库)
缓存: Redis 7.x (会话 + 实时状态)
消息队列: RabbitMQ 3.x
ORM框架: MyBatis Plus 3.x
构建工具: Maven 3.9+
```

#### 前端技术栈
```yaml
核心框架: Vue 3.4+
编程语言: TypeScript 5.x
状态管理: Pinia 2.x
UI组件库: Element Plus 2.x
代码编辑器: Monaco Editor 0.45+
构建工具: Vite 5.x
HTTP客户端: Axios 1.x
实时通信: WebSocket API
```

#### 基础设施
```yaml
容器化: Docker + Docker Compose
代理服务器: Nginx 1.24+
监控: Spring Boot Actuator + Prometheus
日志: Logback + JSON格式
```

### 🤔 决策理由

#### 选择 Spring Boot 的原因
```yaml
技术成熟度:
  ✅ 企业级框架，生态系统完善
  ✅ 大量生产环境验证，稳定性高
  ✅ Spring WebSocket 对实时通信支持优秀
  ✅ 自动配置减少样板代码

性能表现:
  ✅ JVM性能优秀，适合高并发场景
  ✅ 连接池、缓存等优化机制完善
  ✅ 支持响应式编程（WebFlux）

开发体验:
  ✅ IDE支持完善（IntelliJ IDEA）
  ✅ 调试和性能分析工具丰富
  ✅ Spring Boot DevTools 提升开发效率

求职价值:
  ✅ Java岗位需求量大
  ✅ 面试官熟悉度高
  ✅ 企业广泛采用
```

#### 选择 Vue 3 的原因
```yaml
学习成本:
  ✅ 渐进式框架，上手容易
  ✅ 模板语法接近HTML，学习曲线平缓
  ✅ 文档质量高，中文资料丰富

技术特性:
  ✅ Composition API 提供更好的逻辑复用
  ✅ TypeScript支持优秀
  ✅ 性能优化（Proxy响应式系统）
  ✅ Tree-shaking支持，包体积小

生态系统:
  ✅ Element Plus组件库成熟
  ✅ Monaco Editor集成方便
  ✅ Vite构建速度快
```

#### 选择 MySQL 的原因
```yaml
数据特性:
  ✅ 项目以关系型数据为主（用户、项目、文件）
  ✅ ACID特性保证数据一致性
  ✅ 成熟的主从复制和集群方案

技术生态:
  ✅ MyBatis Plus ORM支持完善
  ✅ 监控和运维工具丰富
  ✅ 云厂商支持好（阿里云RDS、腾讯云MySQL）

团队因素:
  ✅ 学习成本最低
  ✅ 调试和问题排查简单
  ✅ 求职市场需求量大
```

### 🔄 考虑的替代方案

#### 替代方案1: Node.js + React
```yaml
优势:
  ✅ 全栈JavaScript，技术栈统一
  ✅ npm生态丰富
  ✅ 开发效率高

劣势:
  ❌ 单线程模型，CPU密集型任务性能差
  ❌ 企业级特性相对较弱
  ❌ TypeScript支持不如Java原生
  ❌ 大型项目维护复杂度高

决策: 不采用，企业级特性不足
```

#### 替代方案2: Go + Angular
```yaml
优势:
  ✅ Go语言性能优秀
  ✅ 并发处理能力强
  ✅ Angular企业级特性丰富

劣势:
  ❌ Go语言学习成本较高
  ❌ ORM和生态相对不成熟
  ❌ Angular学习曲线陡峭
  ❌ 求职市场相对较小

决策: 不采用，学习成本过高
```

#### 替代方案3: Python Django + React
```yaml
优势:
  ✅ Python语法简洁，开发效率高
  ✅ Django框架功能完整
  ✅ AI/ML生态丰富

劣势:
  ❌ 性能相对较差
  ❌ GIL限制并发能力
  ❌ 企业级Java岗位更多
  ❌ 实时系统开发经验相对较少

决策: 不采用，性能和求职考虑
```

### 📈 预期影响评估

```yaml
开发效率: ⭐⭐⭐⭐
  - 技术栈成熟，开发工具完善
  - 学习资料丰富，问题解决快速

性能表现: ⭐⭐⭐⭐⭐
  - JVM性能优秀，适合高并发
  - MySQL + Redis组合经过大量验证

可维护性: ⭐⭐⭐⭐
  - 代码结构清晰，Spring Boot约定大于配置
  - TypeScript提升前端代码质量

团队学习: ⭐⭐⭐⭐⭐
  - 主流技术栈，学习资源丰富
  - 求职价值高，市场需求大

风险控制: ⭐⭐⭐⭐⭐
  - 技术成熟度高，生产环境验证充分
  - 社区活跃，问题解决及时
```

---

## ADR-002: 数据存储架构设计

**日期**: 2024-08-14  
**状态**: ✅ 已采纳  
**决策者**: 架构团队  

### 🎯 决策
采用 **MySQL + Redis + RabbitMQ** 的多数据源架构

### 📊 数据存储分层设计

#### MySQL - 持久化业务数据
```yaml
用途: 
  - 用户账户信息
  - 项目元数据
  - 文件结构信息
  - 权限和角色数据

优势:
  ✅ ACID特性保证数据一致性
  ✅ 复杂查询支持完善
  ✅ 备份和恢复机制成熟
  ✅ 运维工具丰富

数据库设计:
  - codivio_user: 用户服务数据库
  - codivio_project: 项目服务数据库
  - 读写分离: 主库写入，从库读取
```

#### Redis - 高速缓存和实时状态
```yaml
用途:
  - JWT黑名单和会话缓存
  - 实时协作状态数据
  - 用户在线状态
  - 操作队列缓存

数据库分配:
  - DB0: 用户会话和权限缓存
  - DB1: 实时协作状态
  - DB2: 系统级缓存

优势:
  ✅ 内存存储，读写性能极高
  ✅ 多种数据结构支持
  ✅ 原子操作保证数据一致性
  ✅ 持久化机制防止数据丢失
```

#### RabbitMQ - 异步消息通信
```yaml
用途:
  - 服务间事件通知
  - 实时协作操作分发
  - 系统解耦和异步处理

消息设计:
  - 用户事件队列 (user.events)
  - 项目事件队列 (project.events)  
  - 协作事件队列 (collaboration.events)

优势:
  ✅ 消息可靠性保证
  ✅ 支持多种消息模式
  ✅ 管理界面友好
  ✅ 集群和高可用支持
```

### 🤔 决策理由

#### 为什么不用 PostgreSQL？
```yaml
考虑因素:
  ✅ PostgreSQL功能更强大（JSON、数组支持）
  ✅ 标准SQL兼容性更好
  ✅ 扩展性强

但是:
  ❌ 学习和运维成本较高
  ❌ 国内生态相对较弱
  ❌ MySQL在企业中普及度更高
  ❌ 对于项目需求，MySQL完全够用

结论: MySQL更适合学习项目和求职需求
```

#### 为什么不用 MongoDB？
```yaml
考虑因素:
  ✅ 文档型数据库，灵活性高
  ✅ 水平扩展能力强
  ✅ JSON原生支持

但是:
  ❌ 项目主要是关系型数据
  ❌ 事务支持相对较弱
  ❌ 学习成本较高
  ❌ 求职市场相对较小

结论: 关系型数据为主，MySQL更合适
```

#### 为什么选择 RabbitMQ 而不是 Kafka？
```yaml
RabbitMQ优势:
  ✅ 适合小到中等规模系统
  ✅ 消息可靠性保证更强
  ✅ 管理界面友好，易于调试
  ✅ 支持多种消息模式（点对点、发布订阅）
  ✅ 学习曲线相对平缓

Kafka优势:
  ✅ 高吞吐量，适合大数据场景
  ✅ 分区机制支持高并发

选择理由:
  ✅ 项目规模适中，RabbitMQ性能足够
  ✅ 消息可靠性要求高
  ✅ 学习和运维成本考虑
  ✅ 更容易理解和调试
```

---

## ADR-003: 实时协作算法选择

**日期**: 2024-08-14  
**状态**: ✅ 已采纳  
**决策者**: 技术团队  

### 🎯 决策
采用 **操作转换(Operational Transformation, OT)** 算法实现实时协作

### 🧮 算法对比分析

#### 操作转换 (OT) vs CRDT
```yaml
OT算法特点:
  ✅ 中心化架构，一致性保证强
  ✅ 实现相对简单，调试容易
  ✅ 适合文本编辑场景
  ✅ Google Docs等成功案例
  ✅ 学习资料丰富

CRDT算法特点:
  ✅ 去中心化，网络分区容忍性强
  ✅ 最终一致性保证
  ✅ 适合分布式系统

选择OT的原因:
  ✅ 中心化架构符合项目设计
  ✅ 实现复杂度适中
  ✅ 文本编辑场景性能优秀
  ✅ 便于学习和展示
```

### 🔧 核心实现策略

#### OT算法核心逻辑
```java
@Service
public class OperationTransformService {
    
    public Operation transformAgainst(Operation op1, Operation op2) {
        // 插入-插入转换
        if (op1.isInsert() && op2.isInsert()) {
            if (op1.getPosition() <= op2.getPosition()) {
                return op2.withPosition(op2.getPosition() + op1.getLength());
            }
            return op2;
        }
        
        // 删除-删除转换
        if (op1.isDelete() && op2.isDelete()) {
            return handleDeleteDelete(op1, op2);
        }
        
        // 插入-删除转换
        if (op1.isInsert() && op2.isDelete()) {
            return handleInsertDelete(op1, op2);
        }
        
        return op2;
    }
}
```

#### 状态同步机制
```yaml
客户端操作流程:
  1. 用户编辑文本 → 生成Operation
  2. 立即应用到本地 → 乐观更新UI
  3. 发送到服务器 → WebSocket传输
  4. 服务器转换处理 → OT算法
  5. 广播给其他客户端 → 实时同步

服务器处理流程:
  1. 接收客户端操作
  2. 与待处理操作队列进行转换
  3. 应用到服务器状态
  4. 广播转换后的操作
  5. 定期持久化到数据库
```

### 📈 性能考量

```yaml
延迟控制:
  - WebSocket连接: <50ms
  - 操作转换处理: <10ms
  - 广播延迟: <100ms

并发支持:
  - 单文档: 支持5-10人同时编辑
  - 系统总体: 支持100+在线用户
  - 内存使用: 每个在线文档约1MB

容错机制:
  - 操作序列号保证顺序
  - 心跳检测处理断线
  - 重连后状态同步
```

---

## ADR-004: 微服务架构设计

**日期**: 2024-08-14  
**状态**: ✅ 已采纳  
**决策者**: 架构团队  

### 🎯 决策
采用 **按业务领域拆分** 的微服务架构，共4个核心服务

### 🏗️ 服务拆分策略

#### 拆分原则（DDD思想）
```yaml
单一职责原则:
  ✅ 每个服务只负责一个业务领域
  ✅ 服务边界清晰，避免功能重叠

数据独立原则:
  ✅ 每个服务拥有独立的数据库
  ✅ 不直接访问其他服务的数据库

业务完整原则:
  ✅ 服务内部业务逻辑完整
  ✅ 减少跨服务事务依赖
```

#### 服务划分详情
```yaml
用户服务 (User Service):
  端口: 8081
  职责: 用户认证、权限管理
  数据库: codivio_user (MySQL)
  
项目服务 (Project Service):
  端口: 8082  
  职责: 项目管理、文件系统
  数据库: codivio_project (MySQL)

协作服务 (Collaboration Service):
  端口: 8083
  职责: 实时协作、WebSocket管理
  存储: Redis + RabbitMQ

网关服务 (Gateway Service):
  端口: 8080
  职责: 路由转发、统一认证
  存储: Redis (限流数据)
```

### 🔄 服务通信设计

#### 同步通信 (OpenFeign)
```java
@FeignClient(name = "project-service", url = "http://project-service:8082")
public interface ProjectServiceClient {
    
    @GetMapping("/api/v1/projects/user/{userId}")
    List<ProjectDTO> getUserProjects(@PathVariable("userId") Long userId);
    
    @PostMapping("/api/v1/projects/{projectId}/members")
    void addProjectMember(@PathVariable String projectId, 
                         @RequestBody MemberDTO member);
}
```

#### 异步通信 (RabbitMQ)
```java
// 事件发布
@Service
public class UserEventPublisher {
    public void publishUserCreated(User user) {
        UserCreatedEvent event = new UserCreatedEvent(user.getId(), user.getUsername());
        rabbitTemplate.convertAndSend("user.exchange", "user.created", event);
    }
}

// 事件消费
@RabbitListener(queues = "project.user.created")
public void handleUserCreated(UserCreatedEvent event) {
    projectService.createDefaultWorkspace(event.getUserId());
}
```

### 🤔 为什么不用单体架构？

```yaml
单体架构优势:
  ✅ 部署简单
  ✅ 开发初期效率高
  ✅ 调试方便

微服务优势:
  ✅ 技术栈灵活性
  ✅ 服务独立扩展
  ✅ 故障隔离
  ✅ 团队独立开发

选择微服务的原因:
  ✅ 学习分布式系统设计
  ✅ 体验企业级架构复杂性
  ✅ 面试时有更多技术点可讲
  ✅ 展现系统设计能力
```

---

## ADR-005: 容器化部署方案

**日期**: 2024-08-14  
**状态**: ✅ 已采纳  
**决策者**: DevOps团队  

### 🎯 决策
采用 **Docker + Docker Compose** 实现容器化部署

### 🐳 容器化策略

#### Docker vs 传统部署
```yaml
传统部署问题:
  ❌ 环境依赖复杂（JDK、Node.js、数据库）
  ❌ 不同环境配置差异
  ❌ 部署流程繁琐
  ❌ 扩容困难

Docker优势:
  ✅ 环境一致性保证
  ✅ 一键部署和启动
  ✅ 资源隔离和限制
  ✅ 版本管理简单
  ✅ 便于CI/CD集成
```

#### Docker Compose vs Kubernetes
```yaml
Docker Compose优势:
  ✅ 学习成本低
  ✅ 适合小到中等规模项目
  ✅ 本地开发环境友好
  ✅ 配置简单明了

Kubernetes优势:
  ✅ 企业级容器编排
  ✅ 自动扩缩容
  ✅ 服务发现和负载均衡

选择Docker Compose原因:
  ✅ 项目规模适中
  ✅ 学习和运维成本考虑
  ✅ 快速原型验证
  ✅ 本地开发便利性
```

### 📦 容器架构设计

```yaml
# docker-compose.yml 核心结构
services:
  # 微服务容器
  user-service:
    build: ./user-service
    ports: ["8081:8081"]
    depends_on: [mysql, redis]
    
  project-service:
    build: ./project-service
    ports: ["8082:8082"]
    depends_on: [mysql, redis]
    
  collaboration-service:
    build: ./collaboration-service
    ports: ["8083:8083"]
    depends_on: [redis, rabbitmq]
    
  gateway-service:
    build: ./gateway-service
    ports: ["8080:8080"]
    depends_on: [user-service, project-service, collaboration-service]
    
  # 基础设施容器
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: codivio_root_2024
    volumes: [mysql_data:/var/lib/mysql]
    
  redis:
    image: redis:7-alpine
    command: redis-server --requirepass codivio_redis_2024
    volumes: [redis_data:/data]
    
  rabbitmq:
    image: rabbitmq:3-management-alpine
    environment:
      RABBITMQ_DEFAULT_USER: codivio
      RABBITMQ_DEFAULT_PASS: codivio_mq_2024
    ports: ["15672:15672"]  # 管理界面

一键部署优势:
  ✅ 新团队成员5分钟上手
  ✅ 环境问题基本消除  
  ✅ 演示部署极其简单
  ✅ 面试时可现场展示
```

---

## 🎯 总结：技术决策的面试价值

### 💼 面试中的讲解要点

#### 1. 体现技术思维
```yaml
决策过程展示:
  "我在选择技术栈时，从性能、开发效率、团队背景、求职价值四个维度进行评估..."

权衡分析能力:
  "虽然Go语言性能更好，但考虑到学习成本和生态成熟度，最终选择了Spring Boot..."

风险控制意识:
  "选择成熟技术栈降低项目风险，同时保证了技术深度的学习..."
```

#### 2. 展现架构能力
```yaml
系统设计思维:
  "微服务拆分基于DDD思想，按业务领域划分，确保服务边界清晰..."

技术选型能力:
  "数据存储采用MySQL+Redis+RabbitMQ组合，分别解决持久化、缓存、异步通信需求..."

工程实践经验:
  "Docker容器化部署保证环境一致性，一键启动降低运维复杂度..."
```

#### 3. 突出学习能力
```yaml
技术调研能力:
  "对比了多种实时协作算法，最终选择OT算法平衡了复杂度和性能..."

持续优化思维:
  "架构决策不是一成不变的，会根据项目发展和技术演进持续优化..."
```

### 🚀 技术成长价值

**这套技术决策展现了你的：**
- 🧠 **系统性思维** - 从多个维度评估技术方案
- ⚖️ **权衡分析能力** - 平衡技术和业务需求
- 🎯 **目标导向** - 技术选择服务于项目目标
- 📈 **成长意识** - 技术选择考虑学习和职业发展

**在面试中，这些决策记录就是你技术能力的最好证明！**