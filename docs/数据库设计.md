# Codivio 数据库设计文档

## 🎯 设计原则

遵循**微服务数据库独立原则**，每个服务拥有独立的数据库，通过明确的数据边界保证系统的松耦合和高内聚。

### 核心原则
- 🎯 **数据独立** - 每个微服务拥有独立数据库
- 🔗 **松耦合** - 服务间通过API而非直接数据库访问
- 📊 **数据一致性** - 通过事件驱动保证最终一致性
- ⚡ **性能优化** - 合理使用缓存和索引策略
- 📈 **可扩展性** - 支持水平扩展和分库分表

## 📊 数据架构全景

```
┌─────────────────────────────────────────────────────────────┐
│                        应用服务层                            │
│   User Service    Project Service    Collaboration Service  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       数据存储层                             │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │   MySQL     │  │    Redis    │  │  RabbitMQ   │          │
│  │  持久化数据   │  │   缓存状态   │  │   消息队列   │          │
│  │             │  │             │  │             │          │
│  │ - 用户数据   │  │ - 会话缓存   │  │ - 事件通知   │          │
│  │ - 项目数据   │  │ - 实时状态   │  │ - 异步处理   │          │
│  │ - 文件数据   │  │ - 操作队列   │  │             │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 🗄️ MySQL 关系数据库设计

### 数据库分离策略

按照微服务边界进行数据库分离，确保服务独立性：

```sql
-- 用户服务数据库
CREATE DATABASE codivio_user 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 项目服务数据库  
CREATE DATABASE codivio_project
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;
```

---

## 👤 用户服务数据库 (codivio_user)

### users - 用户基础信息表
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
    email VARCHAR(100) UNIQUE NOT NULL COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    
    -- 基础信息
    nickname VARCHAR(100) COMMENT '昵称',
    avatar_url VARCHAR(255) COMMENT '头像链接',
    
    -- 状态信息
    status TINYINT DEFAULT 1 COMMENT '状态: 0-禁用, 1-正常',
    last_login_at TIMESTAMP NULL COMMENT '最后登录时间',
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    -- 索引
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) COMMENT '用户基础信息表';
```

### user_preferences - 用户偏好设置表
```sql
CREATE TABLE user_preferences (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    
    -- 界面设置
    theme ENUM('light', 'dark') DEFAULT 'dark' COMMENT '主题设置',
    language VARCHAR(10) DEFAULT 'zh-CN' COMMENT '界面语言',
    
    -- 编辑器设置
    editor_font_size TINYINT DEFAULT 14 COMMENT '编辑器字体大小',
    editor_theme VARCHAR(20) DEFAULT 'vs-dark' COMMENT '编辑器主题',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_user_preference (user_id)
) COMMENT '用户偏好设置表';
```

---

## 📁 项目服务数据库 (codivio_project)

### projects - 项目基础信息表
```sql
CREATE TABLE projects (
    id VARCHAR(32) PRIMARY KEY COMMENT '项目ID (雪花算法生成)',
    name VARCHAR(100) NOT NULL COMMENT '项目名称',
    description TEXT COMMENT '项目描述',
    
    -- 所有者信息
    owner_id BIGINT NOT NULL COMMENT '所有者ID',
    
    -- 项目配置
    language VARCHAR(20) DEFAULT 'javascript' COMMENT '主要编程语言',
    
    -- 统计信息
    member_count INT DEFAULT 1 COMMENT '成员数量',
    file_count INT DEFAULT 0 COMMENT '文件数量',
    
    -- 状态信息
    status TINYINT DEFAULT 1 COMMENT '状态: 0-删除, 1-正常',
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '最后活动时间',
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_owner_id (owner_id),
    INDEX idx_language (language),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_last_activity (last_activity_at)
) COMMENT '项目基础信息表';
```

### project_members - 项目成员表
```sql
CREATE TABLE project_members (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id VARCHAR(32) NOT NULL COMMENT '项目ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    
    -- 权限信息
    role ENUM('owner', 'editor', 'viewer') DEFAULT 'editor' COMMENT '角色',
    
    -- 时间信息
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '加入时间',
    last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '最后访问时间',
    
    UNIQUE KEY unique_member (project_id, user_id),
    INDEX idx_project_id (project_id),
    INDEX idx_user_id (user_id),
    INDEX idx_role (role),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
) COMMENT '项目成员表';
```

### project_files - 项目文件表
```sql
CREATE TABLE project_files (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id VARCHAR(32) NOT NULL COMMENT '项目ID',
    
    -- 文件信息
    file_path VARCHAR(500) NOT NULL COMMENT '文件路径',
    file_name VARCHAR(255) NOT NULL COMMENT '文件名',
    content LONGTEXT COMMENT '文件内容',
    size INT DEFAULT 0 COMMENT '文件大小(字节)',
    
    -- 文件类型
    type ENUM('file', 'directory') DEFAULT 'file' COMMENT '类型',
    
    -- 编辑信息
    last_editor_id BIGINT COMMENT '最后编辑者ID',
    last_edited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '最后编辑时间',
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_file (project_id, file_path),
    INDEX idx_project_id (project_id),
    INDEX idx_type (type),
    INDEX idx_updated_at (updated_at),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
) COMMENT '项目文件表';
```

---

## 🚀 Redis 缓存设计

### 缓存分层策略

Redis作为高性能缓存层，按数据类型和生命周期进行分库管理：

```yaml
# Redis数据库分配
databases:
  0: # 用户会话和认证
    description: "用户认证和会话管理"
    ttl: 7200  # 2小时
    keys:
      - "user:session:{userId}"       # 用户会话信息
      - "user:token:blacklist:{token}" # JWT黑名单
      - "user:online:{userId}"        # 用户在线状态
      
  1: # 实时协作状态
    description: "实时编辑和协作数据"
    ttl: 1800  # 30分钟
    keys:
      - "document:content:{fileId}"        # 文档当前内容
      - "document:version:{fileId}"        # 文档版本号
      - "document:users:{fileId}"          # 文档在线用户列表
      - "operation:queue:{fileId}"         # 操作转换队列
      - "cursor:position:{fileId}:{userId}" # 用户光标位置
      
  2: # 系统缓存
    description: "系统配置和统计数据"
    ttl: 3600  # 1小时
    keys:
      - "project:info:{projectId}"         # 项目信息缓存
      - "project:members:{projectId}"      # 项目成员缓存
      - "rate:limit:{userId}:{endpoint}"   # 用户限流计数
```

### 关键数据结构

#### 1. 用户会话缓存
```json
// Key: user:session:{userId}
// Type: Hash
{
  "userId": "12345",
  "username": "john_doe",
  "nickname": "John",
  "email": "john@example.com",
  "avatar": "https://avatar.codivio.dev/john.png",
  "roles": ["user"],
  "loginTime": "1640995200000",
  "lastActiveTime": "1640995200000"
}
```

#### 2. 实时文档状态
```json
// Key: document:content:{fileId}
// Type: Hash
{
  "projectId": "proj_abc123",
  "filePath": "/src/App.js",
  "content": "import React from 'react';...",
  "version": "42",
  "lastModified": "1640995200000"
}
```

#### 3. 在线用户列表
```json
// Key: document:users:{fileId}
// Type: Set
[
  "user_12345",
  "user_67890"
]
```

#### 4. 操作转换队列
```json
// Key: operation:queue:{fileId}
// Type: List
[
  {
    "id": "op_123",
    "type": "insert",
    "position": 100,
    "text": "Hello, World!",
    "userId": "12345",
    "timestamp": 1640995200000
  }
]
```

#### 5. 用户光标位置
```json
// Key: cursor:position:{fileId}:{userId}
// Type: Hash
{
  "line": "10",
  "column": "25",
  "selection_start": "150",
  "selection_end": "165",
  "timestamp": "1640995200000"
}
```

---

## 🔄 数据一致性设计

### 微服务间数据同步

采用**事件驱动架构**保证数据的最终一致性：

#### 事件发布示例
```java
// 用户服务 - 发布用户创建事件
@Service
public class UserEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void publishUserCreatedEvent(User user) {
        UserCreatedEvent event = UserCreatedEvent.builder()
            .userId(user.getId())
            .username(user.getUsername())
            .email(user.getEmail())
            .nickname(user.getNickname())
            .timestamp(System.currentTimeMillis())
            .build();
            
        rabbitTemplate.convertAndSend(
            "user.exchange", 
            "user.created", 
            event
        );
    }
}
```

#### 事件消费示例
```java
// 项目服务 - 消费用户创建事件
@Component
public class UserEventListener {
    
    @RabbitListener(queues = "project.user.created")
    public void handleUserCreated(UserCreatedEvent event) {
        // 创建用户在项目服务中的基础数据
        UserProjectProfile profile = UserProjectProfile.builder()
            .userId(event.getUserId())
            .username(event.getUsername())
            .nickname(event.getNickname())
            .build();
            
        userProjectProfileService.createProfile(profile);
    }
}
```

### 缓存更新策略

#### 写通策略 (Write-Through)
```java
@Service
public class ProjectCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProjectService projectService;
    
    public void updateProject(String projectId, Project project) {
        // 1. 更新数据库
        projectService.updateProject(projectId, project);
        
        // 2. 更新缓存
        String cacheKey = "project:info:" + projectId;
        redisTemplate.opsForValue().set(
            cacheKey, 
            JSON.toJSONString(project),
            Duration.ofHours(1)
        );
        
        // 3. 发布更新事件
        publishProjectUpdatedEvent(project);
    }
}
```

#### 缓存失效策略
```java
@Service
public class CacheInvalidationService {
    
    public void invalidateProjectCache(String projectId) {
        // 删除项目信息缓存
        redisTemplate.delete("project:info:" + projectId);
        
        // 删除项目成员缓存
        redisTemplate.delete("project:members:" + projectId);
        
        // 发布缓存失效事件
        publishCacheInvalidationEvent(projectId);
    }
}
```

---

## 📈 性能优化策略

### MySQL 查询优化

#### 常用查询语句
```sql
-- 1. 获取用户项目列表（分页查询）
SELECT 
    p.id,
    p.name,
    p.description,
    p.language,
    p.last_activity_at,
    pm.role,
    pm.joined_at
FROM projects p
INNER JOIN project_members pm ON p.id = pm.project_id
WHERE pm.user_id = ? 
  AND p.status = 1
ORDER BY p.last_activity_at DESC
LIMIT ?, ?;

-- 2. 获取项目文件树
SELECT 
    file_path,
    file_name,
    type,
    size,
    last_edited_at
FROM project_files
WHERE project_id = ?
  AND file_path LIKE CONCAT(?, '%')
ORDER BY type DESC, file_name ASC;

-- 3. 检查用户项目权限
SELECT pm.role
FROM project_members pm
WHERE pm.project_id = ? 
  AND pm.user_id = ?
LIMIT 1;
```

#### 索引优化建议
```sql
-- 复合索引优化
CREATE INDEX idx_project_members_user_project ON project_members(user_id, project_id);
CREATE INDEX idx_project_files_project_path ON project_files(project_id, file_path);
CREATE INDEX idx_projects_owner_status ON projects(owner_id, status);

-- 查询性能分析
EXPLAIN SELECT p.*, pm.role 
FROM projects p 
INNER JOIN project_members pm ON p.id = pm.project_id 
WHERE pm.user_id = 12345;
```

### Redis 性能优化

#### 连接池配置
```yaml
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    password: your_password
    database: 0
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 8
        min-idle: 2
        max-wait: 2000ms
```

#### 批量操作优化
```java
@Service
public class RedisBatchService {
    
    public void batchUpdateUserSessions(Map<String, UserSession> sessions) {
        // 使用Pipeline批量操作
        redisTemplate.executePipelined(new RedisCallback<Object>() {
            @Override
            public Object doInRedis(RedisConnection connection) {
                sessions.forEach((userId, session) -> {
                    String key = "user:session:" + userId;
                    String value = JSON.toJSONString(session);
                    connection.setEx(key.getBytes(), 7200, value.getBytes());
                });
                return null;
            }
        });
    }
}
```

---

## 🎯 数据库监控和维护

### 监控指标

#### MySQL 关键指标
```sql
-- 查询性能监控
SELECT 
    schema_name,
    digest_text,
    avg_timer_wait/1000000000 as avg_exec_time_sec,
    exec_count,
    sum_timer_wait/1000000000 as total_exec_time_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE schema_name = 'codivio_project'
ORDER BY avg_timer_wait DESC 
LIMIT 10;

-- 连接数监控
SHOW GLOBAL STATUS LIKE 'Threads_connected';
SHOW GLOBAL STATUS LIKE 'Max_used_connections';

-- 缓冲池命中率
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_reads';
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_read_requests';
```

#### Redis 监控指标
```bash
# Redis性能监控命令
redis-cli INFO stats
redis-cli INFO memory
redis-cli INFO clients
redis-cli SLOWLOG GET 10

# 键空间分析
redis-cli --bigkeys
redis-cli --memkeys
```

### 备份和恢复

#### MySQL 备份策略
```bash
#!/bin/bash
# 每日备份脚本

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/var/backups/mysql"

# 备份用户数据库
mysqldump -u backup_user -p codivio_user \
  --single-transaction \
  --routines \
  --triggers \
  > $BACKUP_DIR/codivio_user_$DATE.sql

# 备份项目数据库
mysqldump -u backup_user -p codivio_project \
  --single-transaction \
  --routines \
  --triggers \
  > $BACKUP_DIR/codivio_project_$DATE.sql

# 压缩备份文件
gzip $BACKUP_DIR/codivio_*_$DATE.sql

# 删除7天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete
```

#### Redis 备份策略
```bash
#!/bin/bash
# Redis备份脚本

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/var/backups/redis"

# 执行BGSAVE
redis-cli BGSAVE

# 等待备份完成
while [ $(redis-cli LASTSAVE) -eq $LASTSAVE ]; do
  sleep 1
done

# 复制RDB文件
cp /var/lib/redis/dump.rdb $BACKUP_DIR/dump_$DATE.rdb
gzip $BACKUP_DIR/dump_$DATE.rdb

# 删除7天前的备份
find $BACKUP_DIR -name "dump_*.rdb.gz" -mtime +7 -delete
```

---

## 🎯 面试准备要点

### 💡 技术亮点

1. **微服务数据库隔离** - 每个服务独立数据库，避免数据耦合
2. **多数据源架构** - MySQL + Redis + RabbitMQ 组合使用  
3. **缓存分层设计** - 按业务特性合理配置缓存策略
4. **事件驱动一致性** - 通过消息队列保证数据最终一致性
5. **性能优化实践** - 索引设计、查询优化、连接池配置

### 🎯 常见面试问题

#### 1. "为什么不使用单一数据库而要分库？"
```yaml
回答要点:
  - 微服务架构原则，数据独立性
  - 服务边界清晰，避免数据耦合
  - 支持独立扩展和技术选型
  - 故障隔离，单个服务故障不影响全局
  - 符合DDD领域驱动设计思想
```

#### 2. "如何保证分布式系统的数据一致性？"
```yaml
回答要点:
  - 采用最终一致性而非强一致性
  - 事件驱动架构，通过消息队列同步
  - 补偿机制处理失败场景
  - 幂等性设计避免重复处理
  - 监控和告警机制及时发现问题
```

#### 3. "Redis在系统中的作用和价值？"
```yaml
回答要点:
  - 高性能缓存，减少数据库压力
  - 会话存储，支持分布式部署
  - 实时数据存储，支持协作功能
  - 分布式锁，保证并发安全
  - 消息队列，解耦服务通信
```

#### 4. "如何设计数据库索引？"
```yaml
回答要点:
  - 分析查询场景，创建合适索引
  - 复合索引考虑字段顺序
  - 避免过多索引影响写性能
  - 定期分析慢查询优化索引
  - 考虑覆盖索引减少回表
```

### 🚀 扩展设计思考

当面试官问"如果数据量增长1000倍怎么办？"

```yaml
数据库层面:
  - 分库分表，按业务维度水平拆分
  - 读写分离，主从复制分担读压力
  - 数据归档，历史数据迁移到归档库

缓存层面:
  - Redis集群，支持更大内存容量
  - 多级缓存，本地缓存 + 分布式缓存
  - 缓存预热，热点数据提前加载

存储层面:
  - 分布式文件系统存储大文件
  - 对象存储服务替代本地存储
  - CDN加速静态资源访问
```