# Codivio 系统架构设计

## 🎯 项目定位

**Codivio** - 专注于小团队（3-5人）的分布式实时代码协作平台

### 核心特性
- 🔥 **分布式微服务架构** - 学习企业级架构设计
- ⚡ **实时协作编辑** - 多人同步编辑，冲突解决
- 🐳 **Docker容器化** - 一键部署，弹性扩容
- 🏗️ **项目管理** - 文件树，权限控制，团队协作

## 🏗️ 整体架构

### MVP架构全景图
```
┌─────────────────────────────────────────────────────────────┐
│                     前端用户界面                              │
│                   Vue 3 + TypeScript                        │
│              Monaco Editor + WebSocket                      │
└─────────────────────────────────────────────────────────────┘
                              │ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                      Nginx 负载均衡                          │
│                   SSL终止 + 静态资源                          │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Spring Gateway 网关                       │
│              路由转发 + 统一认证 + 限流                        │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
   ┌─────────┐         ┌─────────┐         ┌─────────┐
   │ 用户服务  │         │ 项目服务  │         │ 协作服务  │
   │ :8081   │◄────────┤ :8082   │────────►│ :8083   │
   │JWT认证   │         │文件管理  │         │实时编辑  │
   └─────────┘         └─────────┘         └─────────┘
        │                     │                     │
        │                     │              ┌─────────┐
        │                     │              │RabbitMQ │
        │                     │              │消息队列  │
        │                     │              └─────────┘
        │                     │                     │
   ┌─────────┐         ┌─────────┐         ┌─────────┐
   │ MySQL   │         │ MySQL   │         │ Redis   │
   │ 用户数据  │         │ 项目数据  │         │ 实时状态  │
   └─────────┘         └─────────┘         └─────────┘
```

## 🧩 微服务拆分策略

### 按业务领域拆分（DDD原则）

#### 1. 用户服务 (User Service) - 端口 8081
```yaml
业务职责:
  - 用户注册/登录/登出
  - JWT 令牌管理和验证
  - 用户信息管理
  - 权限控制

技术栈:
  - Spring Boot 3.x + Spring Security
  - JWT + Redis Session
  - MySQL (用户数据)

Docker镜像: codivio/user-service:latest
```

#### 2. 项目服务 (Project Service) - 端口 8082  
```yaml
业务职责:
  - 项目 CRUD 操作
  - 文件树管理 (增删改查)
  - 团队成员管理
  - 权限分配

技术栈:
  - Spring Boot 3.x + MyBatis Plus
  - MySQL (项目数据)
  - 文件系统操作

Docker镜像: codivio/project-service:latest
```

#### 3. 协作服务 (Collaboration Service) - 端口 8083
```yaml
业务职责:
  - 实时协作编辑
  - WebSocket 连接管理
  - 操作转换算法 (OT)
  - 在线用户管理
  - 简单聊天功能

技术栈:
  - Spring Boot 3.x + WebSocket
  - Redis (实时状态缓存)
  - RabbitMQ (事件通知)

Docker镜像: codivio/collaboration-service:latest
```

#### 4. 网关服务 (Gateway Service) - 端口 8080
```yaml
业务职责:
  - 统一入口路由
  - 负载均衡
  - 统一认证拦截
  - 请求限流

技术栈:
  - Spring Cloud Gateway
  - Redis (限流存储)

Docker镜像: codivio/gateway-service:latest
```

## 🔄 服务间通信架构

### 1. 同步通信 (REST API + OpenFeign)
```java
// 用户服务调用项目服务
@FeignClient(name = "project-service", url = "http://project-service:8082")
public interface ProjectServiceClient {
    
    @GetMapping("/api/projects/user/{userId}")
    List<ProjectDTO> getUserProjects(@PathVariable("userId") Long userId);
    
    @PostMapping("/api/projects/{projectId}/members")
    void addProjectMember(@PathVariable String projectId, 
                         @RequestBody MemberDTO member);
}

// 使用示例
@RestController
public class UserController {
    
    @Autowired
    private ProjectServiceClient projectServiceClient;
    
    @GetMapping("/api/users/{userId}/projects")
    public ResponseEntity<List<ProjectDTO>> getUserProjects(@PathVariable Long userId) {
        List<ProjectDTO> projects = projectServiceClient.getUserProjects(userId);
        return ResponseEntity.ok(projects);
    }
}
```

### 2. 异步通信 (RabbitMQ 消息队列)
```java
// 事件发布者 - 用户服务
@Service
public class UserEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void publishUserCreatedEvent(User user) {
        UserCreatedEvent event = new UserCreatedEvent(user.getId(), user.getUsername());
        rabbitTemplate.convertAndSend("user.exchange", "user.created", event);
    }
}

// 事件消费者 - 项目服务
@Component
public class UserEventListener {
    
    @RabbitListener(queues = "project.user.created")
    public void handleUserCreated(UserCreatedEvent event) {
        // 为新用户创建默认项目文件夹
        projectService.createDefaultWorkspace(event.getUserId());
    }
}
```

### 3. 实时通信 (WebSocket)
```java
// 协作服务中的 WebSocket 处理
@Component
public class CollaborationWebSocketHandler extends TextWebSocketHandler {
    
    private final ConcurrentHashMap<String, Set<WebSocketSession>> documentSessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String documentId = getDocumentId(session);
        documentSessions.computeIfAbsent(documentId, k -> ConcurrentHashMap.newKeySet())
                        .add(session);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        // 处理实时编辑操作
        EditOperation operation = JSON.parseObject(message.getPayload(), EditOperation.class);
        broadcastToOtherUsers(session, operation);
    }
}
```

## 💾 数据存储架构设计

### 数据库选型策略

#### MySQL - 业务数据存储
```sql
-- ==== 用户服务数据库 ====
CREATE DATABASE codivio_user;
USE codivio_user;

-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
    email VARCHAR(100) UNIQUE NOT NULL COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    nickname VARCHAR(50) COMMENT '昵称',
    avatar_url VARCHAR(255) COMMENT '头像地址',
    status TINYINT DEFAULT 1 COMMENT '状态: 1-正常, 0-禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_email (email)
) COMMENT='用户表';

-- ==== 项目服务数据库 ====
CREATE DATABASE codivio_project;
USE codivio_project;

-- 项目表
CREATE TABLE projects (
    id VARCHAR(32) PRIMARY KEY COMMENT '项目ID(雪花算法)',
    name VARCHAR(100) NOT NULL COMMENT '项目名称',
    description TEXT COMMENT '项目描述',
    owner_id BIGINT NOT NULL COMMENT '创建者ID',
    language VARCHAR(20) DEFAULT 'javascript' COMMENT '主要编程语言',
    visibility ENUM('private', 'public') DEFAULT 'private' COMMENT '可见性',
    status TINYINT DEFAULT 1 COMMENT '状态: 1-正常, 0-删除',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_owner (owner_id),
    INDEX idx_status (status)
) COMMENT='项目表';

-- 项目成员表
CREATE TABLE project_members (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id VARCHAR(32) NOT NULL COMMENT '项目ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    role ENUM('owner', 'admin', 'editor', 'viewer') DEFAULT 'editor' COMMENT '角色',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '加入时间',
    UNIQUE KEY uk_project_user (project_id, user_id),
    INDEX idx_user (user_id)
) COMMENT='项目成员表';

-- 文件表
CREATE TABLE project_files (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id VARCHAR(32) NOT NULL COMMENT '项目ID',
    file_path VARCHAR(500) NOT NULL COMMENT '文件路径',
    file_name VARCHAR(255) NOT NULL COMMENT '文件名',
    file_type ENUM('file', 'directory') DEFAULT 'file' COMMENT '类型',
    content LONGTEXT COMMENT '文件内容',
    size BIGINT DEFAULT 0 COMMENT '文件大小(字节)',
    created_by BIGINT NOT NULL COMMENT '创建者',
    updated_by BIGINT COMMENT '最后更新者',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_project_path (project_id, file_path),
    INDEX idx_project (project_id)
) COMMENT='项目文件表';
```

#### Redis - 实时状态管理
```yaml
# Redis 数据结构设计
数据库分配:
  DB0: # JWT 与用户会话
    - "jwt:blacklist:{tokenId}"     # JWT 黑名单
    - "user:session:{userId}"       # 用户在线状态
    - "user:permissions:{userId}"   # 用户权限缓存
    
  DB1: # 实时协作状态
    - "document:content:{fileId}"   # 文档当前内容
    - "document:version:{fileId}"   # 文档版本号
    - "document:users:{fileId}"     # 文档在线用户列表
    - "operation:queue:{fileId}"    # 操作操作队列
    - "cursor:position:{fileId}:{userId}" # 用户光标位置
    
  DB2: # 系统缓存
    - "project:info:{projectId}"    # 项目信息缓存
    - "project:members:{projectId}" # 项目成员缓存
    - "rate:limit:{userId}"         # 用户限流

# 示例数据结构
Redis键值示例:
  # 文档在线用户 (Set)
  "document:users:file_123" : ["user_456", "user_789"]
  
  # 用户光标位置 (Hash)
  "cursor:position:file_123:user_456" : {
    "line": 10,
    "column": 25,
    "timestamp": 1640995200000
  }
  
  # 操作队列 (List)
  "operation:queue:file_123" : [
    {
      "type": "insert",
      "position": 100,
      "text": "hello",
      "userId": "user_456",
      "timestamp": 1640995200000
    }
  ]
```

#### 消息队列 (RabbitMQ) - 事件驱动
```yaml
RabbitMQ 交换机设计:
  交换机:
    - user.events      # 用户相关事件
    - project.events   # 项目相关事件  
    - collaboration.events # 协作相关事件
    
  队列设计:
    # 用户事件队列
    - queue: user.created
      binding: user.events -> user.created
      consumer: project-service
      
    - queue: user.updated  
      binding: user.events -> user.updated
      consumer: collaboration-service
      
    # 项目事件队列
    - queue: project.member.added
      binding: project.events -> project.member.added
      consumer: user-service, collaboration-service
      
    # 协作事件队列
    - queue: collaboration.operation
      binding: collaboration.events -> collaboration.operation
      consumer: project-service (实时保存)
```

## 🔄 实时通信架构

### WebSocket连接管理
```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new CollaborativeEditHandler(), "/ws/editor")
                .setAllowedOrigins("*")
                .withSockJS();
    }
}

// 连接池管理
@Component
public class WebSocketConnectionManager {
    private final Map<String, Set<WebSocketSession>> documentSessions = new ConcurrentHashMap<>();
    private final Map<String, String> sessionToDocument = new ConcurrentHashMap<>();
    
    public void addSession(String documentId, WebSocketSession session) {
        documentSessions.computeIfAbsent(documentId, k -> new ConcurrentHashMap<>())
                        .add(session);
        sessionToDocument.put(session.getId(), documentId);
    }
    
    public void removeSession(WebSocketSession session) {
        String documentId = sessionToDocument.remove(session.getId());
        if (documentId != null) {
            Set<WebSocketSession> sessions = documentSessions.get(documentId);
            if (sessions != null) {
                sessions.remove(session);
            }
        }
    }
}
```

### 操作转换算法核心
```java
@Service
public class OperationTransformService {
    
    public Operation transformOperation(Operation op1, Operation op2) {
        // 插入-插入转换
        if (op1.isInsert() && op2.isInsert()) {
            if (op1.getPosition() <= op2.getPosition()) {
                return op2.withPosition(op2.getPosition() + op1.getLength());
            }
            return op2;
        }
        
        // 删除-删除转换
        if (op1.isDelete() && op2.isDelete()) {
            if (op1.getPosition() + op1.getLength() <= op2.getPosition()) {
                return op2.withPosition(op2.getPosition() - op1.getLength());
            }
            if (op1.getPosition() >= op2.getPosition() + op2.getLength()) {
                return op2;
            }
            // 重叠删除处理
            return handleOverlappingDelete(op1, op2);
        }
        
        // 插入-删除转换
        if (op1.isInsert() && op2.isDelete()) {
            if (op1.getPosition() <= op2.getPosition()) {
                return op2.withPosition(op2.getPosition() + op1.getLength());
            }
            if (op1.getPosition() < op2.getPosition() + op2.getLength()) {
                return op2.withLength(op2.getLength() + op1.getLength());
            }
            return op2;
        }
        
        return op2;
    }
}
```

## 📋 分阶段实现计划

### 🚀 第一阶段 (4-6周) - MVP 核心功能

#### Week 1-2: 基础架构搭建
```yaml
目标: 完成微服务基础框架
任务清单:
  ✅ Docker 环境配置和统一基础镜像
  ✅ MySQL 数据库设计和初始化脚本
  ✅ Redis 缓存配置和数据结构设计
  ✅ RabbitMQ 消息队列搭建
  ✅ 用户服务开发(注册/登录/JWT)
  ✅ Spring Gateway 网关服务搭建
  ✅ docker-compose.yml 统一编排配置

验收标准:
  - 可以一键启动所有基础服务
  - 用户可以注册登录并获取 JWT 令牌
  - 网关正常路由请求到用户服务
```

#### Week 3-4: 项目管理模块
```yaml
目标: 完成项目和文件管理功能
任务清单:
  ✅ 项目服务开发(项目 CRUD)
  ✅ 文件树管理(创建/删除/重命名/移动)
  ✅ 项目成员管理(邀请/移除/权限控制)
  ✅ 文件内容存储和读取
  ✅ 服务间通信(OpenFeign + 消息队列)
  ✅ 前端 Vue3 项目初始化

验收标准:
  - 用户可以创建项目和文件夹
  - 可以邀请成员加入项目
  - 支持文件的增删改查操作
  - 前端界面可以显示项目列表和文件树
```

#### Week 5-6: 实时协作编辑
```yaml
目标: 完成基础的实时协作编辑功能
任务清单:
  ✅ 协作服务 WebSocket 服务器搭建
  ✅ 在线用户管理和状态同步
  ✅ 基础的实时文字同步功能
  ✅ 简单的冲突处理机制
  ✅ 用户光标位置同步
  ✅ 前端 Monaco Editor 集成
  ✅ 实时协作界面开发

验收标准:
  - 多个用户可以同时编辑同一文件
  - 实时看到其他用户的光标位置
  - 文字变更可以实时同步
  - 基本冲突可以正确解决
```

### 🔧 第二阶段 (3-4周) - 功能完善
```yaml
目标: 提升系统稳定性和用户体验
任务清单:
  ✅ 操作转换算法(OT)优化
  ✅ 在线用户列表和状态显示
  ✅ 简单的实时聊天功能
  ✅ 文件历史版本管理
  ✅ 系统监控和日志集成
  ✅ 异常处理和错误恢复
  ✅ 性能优化和压力测试

验收标准:
  - 复杂编辑场景下冲突解决正确
  - 支持 5 个用户同时在线编辑
  - 具备基础的监控和告警能力
```

### 🚀 第三阶段 (可选扩展) - 高级特性
```yaml
目标: 增加高级协作功能
任务清单:
  ✅ Git 版本控制集成
  ✅ 代码执行环境(简单版)
  ✅ 代码 Review 功能
  ✅ 智能代码提示(LSP 集成)
  ✅ 移动端适配
```

## 🔍 技术选型决策记录

### 核心技术决策

#### 1. 微服务拆分策略
```yaml
决策: 按业务领域拆分(DDD) + 单一职责原则

理由:
  ✅ 每个服务职责明确，边界清晰
  ✅ 便于学习微服务架构设计
  ✅ 支持独立开发和部署
  ✅ 降低系统耦合度

替代方案:
  ❌ 单体应用 - 不能体现分布式特性
  ❌ 过细粒度拆分 - 增加复杂度，不适合学习
```

#### 2. 数据存储选型
```yaml
决策: MySQL + Redis + RabbitMQ

理由:
  MySQL:
    ✅ 关系型数据适合用户、项目管理
    ✅ ACID 特性保证数据一致性
    ✅ 成熟稳定，学习成本低
    ✅ 云厂商支持好
  
  Redis:
    ✅ 高性能缓存，适合实时数据
    ✅ 支持多种数据结构
    ✅ 支持发布订阅模式
  
  RabbitMQ:
    ✅ 消息可靠性高，支持事务
    ✅ 管理界面友好，便于调试
    ✅ 支持多种消息模式

替代方案:
  ❌ PostgreSQL - 过度工程化，学习成本高
  ❌ MongoDB - 不适合关系型业务数据
  ❌ Kafka - 对于小项目过于复杂
```

#### 3. 容器化方案
```yaml
决策: Docker + Docker Compose

理由:
  ✅ 环境一致性，避免"在我机器上可以运行"问题
  ✅ 一键部署，降低开发和部署门槛
  ✅ 资源隔离，支持弹性扩容
  ✅ 便于学习容器技术

替代方案:
  ❌ 直接部署 - 环境依赖复杂，难以管理
  ❌ Kubernetes - 对于学习项目过于复杂
```

## 🔐 安全架构设计

### 安全分层防护
```
╔═══════════════════════════════════╗
║           网络安全层                 ║
║  - HTTPS/WSS 加密传输              ║
║  - Nginx 限流和防护                 ║
║  - CORS 跨域访问控制               ║
╚═══════════════════════════════════╝
                   │
╔═══════════════════════════════════╗
║           认证授权层                 ║
║  - JWT 令牌认证                     ║
║  - RBAC 角色权限控制               ║
║  - 统一网关认证                    ║
╚═══════════════════════════════════╝
                   │
╔═══════════════════════════════════╗
║           应用安全层                 ║
║  - 输入验证和参数过滤             ║
║  - SQL 注入防护                    ║
║  - XSS 攻击防护                     ║
╚═══════════════════════════════════╝
                   │
╔═══════════════════════════════════╗
║           数据安全层                 ║
║  - 敏感信息加密存储               ║
║  - 数据库访问控制                  ║
║  - 定期数据备份                     ║
╚═══════════════════════════════════╝
```

### JWT 认证机制
```java
// JWT 配置
@Configuration
public class JwtConfig {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration:86400}") // 24小时
    private int jwtExpiration;
    
    public String generateToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("username", user.getUsername());
        claims.put("roles", user.getRoles());
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(user.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000))
                .signWith(SignatureAlgorithm.HS256, jwtSecret)
                .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            // 检查是否在黑名单中
            if (isTokenBlacklisted(token)) {
                return false;
            }
            
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}

// 网关认证过滤器
@Component
public class JwtAuthenticationFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        
        // 白名单路径（登录、注册等）
        if (isWhiteListPath(path)) {
            return chain.filter(exchange);
        }
        
        String token = extractToken(exchange.getRequest());
        if (token == null || !jwtConfig.validateToken(token)) {
            return unauthorized(exchange.getResponse());
        }
        
        // 将用户信息添加到请求头
        ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
                .header("X-User-Id", getUserIdFromToken(token))
                .header("X-Username", getUsernameFromToken(token))
                .build();
                
        return chain.filter(exchange.mutate().request(mutatedRequest).build());
    }
}
```

### RBAC 权限控制
```java
// 权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value();  // 所需权限
    String resource() default ""; // 资源类型
}

// 权限拦截器
@Aspect
@Component
public class PermissionAspect {
    
    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint point, RequirePermission requirePermission) throws Throwable {
        
        // 获取当前用户
        Long userId = getCurrentUserId();
        String permission = requirePermission.value();
        String resource = requirePermission.resource();
        
        // 检查权限
        if (!permissionService.hasPermission(userId, permission, resource)) {
            throw new AccessDeniedException("没有权限访问: " + permission);
        }
        
        return point.proceed();
    }
}

// 使用示例
@RestController
public class ProjectController {
    
    @PostMapping("/projects")
    @RequirePermission("project:create")
    public ResponseEntity<Project> createProject(@RequestBody ProjectRequest request) {
        // 创建项目逻辑
        return ResponseEntity.ok(projectService.createProject(request));
    }
    
    @PutMapping("/projects/{projectId}")
    @RequirePermission(value = "project:edit", resource = "project")
    public ResponseEntity<Project> updateProject(@PathVariable String projectId, 
                                                @RequestBody ProjectRequest request) {
        // 更新项目逻辑
        return ResponseEntity.ok(projectService.updateProject(projectId, request));
    }
}
```

## 📊 监控和观测性

### Actuator 健康检查
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true

# 健康检查配置
spring:
  datasource:
    hikari:
      connection-test-query: SELECT 1
  redis:
    timeout: 2000ms
```

### 日志集中化
```yaml
# logback-spring.xml
<configuration>
    <springProfile name="docker">
        <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <pattern>
                        <pattern>{
                            "service": "user-service",
                            "version": "1.0.0",
                            "trace_id": "%X{traceId:-}",
                            "span_id": "%X{spanId:-}"
                        }</pattern>
                    </pattern>
                </providers>
            </encoder>
        </appender>
    </springProfile>
</configuration>

# Docker Compose 日志收集
services:
  filebeat:
    image: elastic/filebeat:8.0.0
    volumes:
      - ./logs:/var/log/codivio
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml
    depends_on:
      - elasticsearch
```

---

## 🎆 总结

### 架构亮点
✅ **学习导向**: 专门为学习分布式架构而设计
✅ **技术先进**: 采用主流企业级技术栈
✅ **一键部署**: Docker Compose 统一编排，开箱即用
✅ **可观测性**: 完善的监控、日志和健康检查
✅ **安全可靠**: 多层安全防护，JWT + RBAC 权限控制
✅ **渐进式**: 分阶段实现，每个阶段都有明确目标

### 面试加分项
💡 **微服务架构设计** - 能清晰讲解服务拆分逻辑
💡 **分布式系统经验** - 亲手处理服务间通信、数据一致性
💡 **容器化部署** - 具备 Docker 实战经验
💡 **实时系统设计** - WebSocket + 操作转换算法
💡 **性能优化** - 缓存、消息队列、数据库优化

### 技术成长路径
🚀 **初级阶段**: 掌握微服务基础架构
🚀 **中级阶段**: 理解分布式系统复杂性
🚀 **高级阶段**: 具备企业级系统设计能力
