# Codivio 开发规范手册

## 🎯 编码规范总则

遵循**clean code**原则，确保代码可读性、可维护性和一致性，为团队协作和项目长期发展奠定基础。

### 核心原则
- 🔍 **可读性优先** - 代码是写给人看的，其次才是机器
- 📏 **一致性原则** - 统一的编码风格和命名规范
- 🧩 **模块化设计** - 高内聚低耦合的代码结构
- 🛡️ **安全意识** - 防范常见安全漏洞
- ⚡ **性能考虑** - 编写高效的代码

---

## 🌐 前端开发规范

### 1. Vue.js 编码规范

#### 组件结构规范
```vue
<!-- ✅ 推荐的组件结构 -->
<template>
  <div class="user-profile">
    <!-- 模板内容 -->
    <div class="user-avatar">
      <img :src="user.avatar" :alt="user.name" />
    </div>
    
    <div class="user-info">
      <h3 class="user-name">{{ user.name }}</h3>
      <p class="user-email">{{ user.email }}</p>
    </div>
    
    <div class="user-actions">
      <el-button @click="handleEdit" type="primary">编辑</el-button>
      <el-button @click="handleDelete" type="danger">删除</el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
// 1. 导入依赖
import { ref, computed, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { useUserStore } from '@/stores/user'
import type { User } from '@/types/user'

// 2. 定义Props
interface Props {
  userId: string
  editable?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  editable: true
})

// 3. 定义Emits
interface Emits {
  (e: 'edit', user: User): void
  (e: 'delete', userId: string): void
}

const emit = defineEmits<Emits>()

// 4. 响应式数据
const userStore = useUserStore()
const loading = ref(false)
const user = ref<User | null>(null)

// 5. 计算属性
const displayName = computed(() => {
  return user.value?.nickname || user.value?.name || '未知用户'
})

// 6. 方法定义
const handleEdit = () => {
  if (!user.value) return
  emit('edit', user.value)
}

const handleDelete = async () => {
  if (!user.value) return
  
  try {
    await ElMessageBox.confirm('确定删除此用户吗？', '删除确认')
    emit('delete', user.value.id)
    ElMessage.success('删除成功')
  } catch {
    // 用户取消
  }
}

const fetchUser = async () => {
  loading.value = true
  try {
    user.value = await userStore.fetchUser(props.userId)
  } catch (error) {
    ElMessage.error('获取用户信息失败')
  } finally {
    loading.value = false
  }
}

// 7. 生命周期
onMounted(() => {
  fetchUser()
})
</script>

<style scoped>
.user-profile {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px;
  border: 1px solid var(--el-border-color);
  border-radius: 8px;
}

.user-avatar img {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  object-fit: cover;
}

.user-info {
  flex: 1;
}

.user-name {
  margin: 0 0 4px 0;
  font-size: 16px;
  font-weight: 600;
}

.user-email {
  margin: 0;
  color: var(--el-text-color-secondary);
  font-size: 14px;
}

.user-actions {
  display: flex;
  gap: 8px;
}
</style>
```

#### 命名规范
```yaml
组件命名:
  - 文件名: PascalCase (UserProfile.vue)
  - 组件名: PascalCase (UserProfile)
  - 实例名: camelCase (userProfile)

Props命名:
  - 定义: camelCase (userId, isVisible)
  - 模板: kebab-case (user-id, is-visible)

事件命名:
  - 定义: camelCase (updateUser, deleteItem)
  - 模板: kebab-case (update-user, delete-item)

CSS类名:
  - BEM规范: block__element--modifier
  - 示例: user-card__title--highlighted

常量命名:
  - UPPER_SNAKE_CASE (MAX_RETRY_COUNT)
```

#### 组件设计原则
```typescript
// ✅ 单一职责原则
// 每个组件只负责一个功能
const UserCard = defineComponent({ /* 只负责展示用户卡片 */ })
const UserEditor = defineComponent({ /* 只负责编辑用户 */ })

// ✅ Props设计原则
interface Props {
  // 必需的props在前
  userId: string
  
  // 可选的props在后，提供默认值
  editable?: boolean
  showActions?: boolean
  
  // 复杂类型明确定义
  user?: User | null
  
  // 回调函数明确参数类型
  onUpdate?: (user: User) => void
}

// ✅ 事件设计原则
interface Emits {
  // 使用动词+名词的形式
  (e: 'update:user', user: User): void
  (e: 'delete:user', userId: string): void
  
  // 携带明确的参数类型
  (e: 'status:change', status: 'loading' | 'success' | 'error'): void
}

// ❌ 避免的做法
interface BadProps {
  data: any  // 类型不明确
  config: object  // 结构不清晰
}
```

### 2. TypeScript 规范

#### 类型定义规范
```typescript
// ✅ API响应类型定义
interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
  timestamp: number
}

// ✅ 业务实体类型
interface User {
  readonly id: string
  username: string
  email: string
  nickname?: string
  avatar?: string
  status: UserStatus
  permissions: Permission[]
  createdAt: Date
  updatedAt: Date
}

// ✅ 枚举定义
enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended'
}

// ✅ 联合类型
type Theme = 'light' | 'dark' | 'auto'
type ResponseStatus = 'idle' | 'loading' | 'success' | 'error'

// ✅ 泛型工具类型
type Partial<T> = {
  [P in keyof T]?: T[P]
}

type ApiEndpoint<T> = {
  url: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  params?: Record<string, any>
  data?: T
}

// ✅ 条件类型
type NonNullable<T> = T extends null | undefined ? never : T

// ✅ 映射类型
type UserUpdatePayload = Pick<User, 'username' | 'email' | 'nickname'>
type UserCreatePayload = Omit<User, 'id' | 'createdAt' | 'updatedAt'>
```

#### 函数签名规范
```typescript
// ✅ 明确的函数签名
async function fetchUserById(
  userId: string,
  options?: {
    includePermissions?: boolean
    includeProjects?: boolean
  }
): Promise<User> {
  // 实现
}

// ✅ 泛型函数
function createApiClient<T>(baseURL: string): ApiClient<T> {
  // 实现
}

// ✅ 函数重载
function formatDate(date: Date): string
function formatDate(date: string): string
function formatDate(date: number): string
function formatDate(date: Date | string | number): string {
  // 实现
}

// ✅ 高阶函数类型
type EventHandler<T = any> = (event: T) => void | Promise<void>
type ApiCall<TParams, TResponse> = (params: TParams) => Promise<TResponse>

// ✅ 装饰器类型
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T {
  // 实现
}
```

### 3. 样式规范

#### CSS/SCSS 规范
```scss
// ✅ 变量定义
:root {
  // 颜色系统
  --color-primary: #007bff;
  --color-success: #28a745;
  --color-warning: #ffc107;
  --color-danger: #dc3545;
  
  // 间距系统
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  // 字体系统
  --font-size-xs: 12px;
  --font-size-sm: 14px;
  --font-size-md: 16px;
  --font-size-lg: 18px;
  --font-size-xl: 20px;
  
  // 边框圆角
  --border-radius-sm: 4px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  
  // 阴影
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.1);
}

// ✅ BEM命名规范
.user-card {
  display: flex;
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-sm);
  
  &__avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    margin-right: var(--spacing-md);
    
    &--large {
      width: 64px;
      height: 64px;
    }
  }
  
  &__content {
    flex: 1;
  }
  
  &__title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
    
    &--highlighted {
      color: var(--color-primary);
    }
  }
  
  &__description {
    font-size: var(--font-size-sm);
    color: var(--text-color-secondary);
    line-height: 1.4;
  }
  
  &__actions {
    display: flex;
    gap: var(--spacing-sm);
    margin-left: var(--spacing-md);
  }
  
  // 状态修饰符
  &--loading {
    opacity: 0.6;
    pointer-events: none;
  }
  
  &--disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
}

// ✅ 响应式设计
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--spacing-md);
  
  @media (max-width: 768px) {
    padding: 0 var(--spacing-sm);
  }
}

// ✅ 动画效果
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

// ✅ 工具类
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-truncate { 
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

#### 性能优化规范
```scss
// ✅ 避免深层嵌套（最多3层）
.navigation {
  .menu {
    .item {
      // 最多到这一层
    }
  }
}

// ✅ 使用高效选择器
.user-list-item { /* 类选择器性能好 */ }
#user-profile { /* ID选择器性能最好 */ }

// ❌ 避免低效选择器
* { /* 通配符选择器性能差 */ }
div > div > div { /* 多层标签选择器性能差 */ }
[data-id="123"] { /* 属性选择器性能一般 */ }

// ✅ 合理使用CSS变量
.theme-dark {
  --text-color: #ffffff;
  --bg-color: #1a1a1a;
}

.theme-light {
  --text-color: #333333;
  --bg-color: #ffffff;
}
```

---

## ⚙️ 后端开发规范

### 1. Java/Spring Boot 规范

#### 项目结构规范
```
src/main/java/com/codivio/userservice/
├── UserServiceApplication.java          # 启动类
├── config/                              # 配置类
│   ├── DatabaseConfig.java
│   ├── RedisConfig.java
│   └── SecurityConfig.java
├── controller/                          # 控制器层
│   ├── UserController.java
│   └── AuthController.java
├── service/                             # 服务层
│   ├── UserService.java
│   ├── UserServiceImpl.java
│   └── AuthService.java
├── repository/                          # 数据访问层
│   ├── UserRepository.java
│   └── UserMapper.java
├── domain/                              # 实体类
│   ├── entity/
│   │   └── User.java
│   ├── dto/
│   │   ├── UserDTO.java
│   │   └── CreateUserRequest.java
│   └── vo/
│       └── UserProfileVO.java
├── exception/                           # 异常处理
│   ├── GlobalExceptionHandler.java
│   ├── BusinessException.java
│   └── ErrorCode.java
├── util/                                # 工具类
│   ├── JwtUtil.java
│   └── PasswordUtil.java
└── constant/                            # 常量定义
    └── UserConstants.java
```

#### 控制器规范
```java
/**
 * 用户管理控制器
 * 
 * @author 开发者姓名
 * @since 1.0.0
 */
@RestController
@RequestMapping("/api/v1/users")
@Validated
@Slf4j
@Tag(name = "用户管理", description = "用户相关API")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    /**
     * 获取用户列表
     *
     * @param params 查询参数
     * @return 用户列表
     */
    @GetMapping
    @Operation(summary = "获取用户列表", description = "支持分页和条件查询")
    @ApiResponse(responseCode = "200", description = "获取成功")
    public ResponseEntity<PageResult<UserDTO>> getUsers(
            @Valid @ModelAttribute UserQueryParams params) {
        
        log.info("获取用户列表，参数: {}", params);
        
        PageResult<UserDTO> result = userService.getUsers(params);
        return ResponseEntity.ok(result);
    }

    /**
     * 根据ID获取用户
     *
     * @param userId 用户ID
     * @return 用户信息
     */
    @GetMapping("/{userId}")
    @Operation(summary = "获取用户详情")
    public ResponseEntity<UserDTO> getUserById(
            @PathVariable @NotBlank(message = "用户ID不能为空") String userId) {
        
        log.info("获取用户详情，ID: {}", userId);
        
        UserDTO user = userService.getUserById(userId);
        return ResponseEntity.ok(user);
    }

    /**
     * 创建用户
     *
     * @param request 创建用户请求
     * @return 创建的用户信息
     */
    @PostMapping
    @Operation(summary = "创建用户")
    public ResponseEntity<UserDTO> createUser(
            @Valid @RequestBody CreateUserRequest request) {
        
        log.info("创建用户，请求: {}", request);
        
        UserDTO user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    /**
     * 更新用户
     *
     * @param userId 用户ID
     * @param request 更新请求
     * @return 更新后的用户信息
     */
    @PutMapping("/{userId}")
    @Operation(summary = "更新用户")
    public ResponseEntity<UserDTO> updateUser(
            @PathVariable @NotBlank String userId,
            @Valid @RequestBody UpdateUserRequest request) {
        
        log.info("更新用户，ID: {}, 请求: {}", userId, request);
        
        UserDTO user = userService.updateUser(userId, request);
        return ResponseEntity.ok(user);
    }

    /**
     * 删除用户
     *
     * @param userId 用户ID
     * @return 无内容响应
     */
    @DeleteMapping("/{userId}")
    @Operation(summary = "删除用户")
    public ResponseEntity<Void> deleteUser(
            @PathVariable @NotBlank String userId) {
        
        log.info("删除用户，ID: {}", userId);
        
        userService.deleteUser(userId);
        return ResponseEntity.noContent().build();
    }
}
```

#### 服务层规范
```java
/**
 * 用户服务实现类
 */
@Service
@Transactional(readOnly = true)
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    private final RedisTemplate<String, Object> redisTemplate;

    public UserServiceImpl(
            UserRepository userRepository,
            PasswordEncoder passwordEncoder,
            UserMapper userMapper,
            RedisTemplate<String, Object> redisTemplate) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.userMapper = userMapper;
        this.redisTemplate = redisTemplate;
    }

    @Override
    public PageResult<UserDTO> getUsers(UserQueryParams params) {
        // 参数验证
        Assert.notNull(params, "查询参数不能为空");
        
        // 构建查询条件
        Page<User> page = userRepository.findByConditions(
            params.getKeyword(),
            params.getStatus(),
            PageRequest.of(params.getPage() - 1, params.getSize())
        );
        
        // 转换DTO
        List<UserDTO> userDTOs = page.getContent()
            .stream()
            .map(userMapper::toDTO)
            .collect(Collectors.toList());
        
        return PageResult.<UserDTO>builder()
            .data(userDTOs)
            .total(page.getTotalElements())
            .page(params.getPage())
            .size(params.getSize())
            .build();
    }

    @Override
    public UserDTO getUserById(String userId) {
        // 参数验证
        Assert.hasText(userId, "用户ID不能为空");
        
        // 先从缓存获取
        String cacheKey = CacheConstants.USER_INFO_KEY + userId;
        UserDTO cachedUser = (UserDTO) redisTemplate.opsForValue().get(cacheKey);
        if (cachedUser != null) {
            log.debug("从缓存获取用户信息: {}", userId);
            return cachedUser;
        }
        
        // 从数据库获取
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("用户不存在: " + userId));
        
        UserDTO userDTO = userMapper.toDTO(user);
        
        // 缓存用户信息
        redisTemplate.opsForValue().set(cacheKey, userDTO, Duration.ofHours(1));
        
        return userDTO;
    }

    @Override
    @Transactional
    public UserDTO createUser(CreateUserRequest request) {
        // 参数验证
        Assert.notNull(request, "创建用户请求不能为空");
        validateCreateUserRequest(request);
        
        // 检查用户名是否已存在
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new BusinessException(ErrorCode.USERNAME_ALREADY_EXISTS);
        }
        
        // 检查邮箱是否已存在
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_ALREADY_EXISTS);
        }
        
        // 构建用户实体
        User user = User.builder()
            .id(IdGenerator.nextId())
            .username(request.getUsername())
            .email(request.getEmail())
            .passwordHash(passwordEncoder.encode(request.getPassword()))
            .nickname(request.getNickname())
            .status(UserStatus.ACTIVE)
            .createdAt(LocalDateTime.now())
            .updatedAt(LocalDateTime.now())
            .build();
        
        // 保存用户
        User savedUser = userRepository.save(user);
        
        // 发布用户创建事件
        eventPublisher.publishEvent(new UserCreatedEvent(savedUser.getId()));
        
        log.info("用户创建成功: {}", savedUser.getId());
        
        return userMapper.toDTO(savedUser);
    }

    /**
     * 验证创建用户请求
     */
    private void validateCreateUserRequest(CreateUserRequest request) {
        // 用户名格式验证
        if (!request.getUsername().matches("^[a-zA-Z0-9_]{3,20}$")) {
            throw new BusinessException(ErrorCode.INVALID_USERNAME_FORMAT);
        }
        
        // 密码强度验证
        if (!isPasswordStrong(request.getPassword())) {
            throw new BusinessException(ErrorCode.WEAK_PASSWORD);
        }
        
        // 邮箱格式验证
        if (!EmailValidator.getInstance().isValid(request.getEmail())) {
            throw new BusinessException(ErrorCode.INVALID_EMAIL_FORMAT);
        }
    }

    /**
     * 检查密码强度
     */
    private boolean isPasswordStrong(String password) {
        // 至少8位，包含大小写字母、数字和特殊字符
        return password.length() >= 8 &&
               password.matches(".*[a-z].*") &&
               password.matches(".*[A-Z].*") &&
               password.matches(".*[0-9].*") &&
               password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?].*");
    }
}
```

#### 实体类规范
```java
/**
 * 用户实体
 */
@Entity
@Table(name = "users")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class User extends BaseEntity {

    /**
     * 用户ID
     */
    @Id
    @Column(name = "id", length = 32)
    private String id;

    /**
     * 用户名
     */
    @Column(name = "username", length = 50, nullable = false, unique = true)
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;

    /**
     * 邮箱
     */
    @Column(name = "email", length = 100, nullable = false, unique = true)
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;

    /**
     * 密码哈希
     */
    @Column(name = "password_hash", nullable = false)
    @NotBlank(message = "密码不能为空")
    @JsonIgnore
    private String passwordHash;

    /**
     * 昵称
     */
    @Column(name = "nickname", length = 100)
    @Size(max = 50, message = "昵称不能超过50个字符")
    private String nickname;

    /**
     * 头像URL
     */
    @Column(name = "avatar_url")
    @URL(message = "头像URL格式不正确")
    private String avatarUrl;

    /**
     * 用户状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @NotNull(message = "用户状态不能为空")
    private UserStatus status;

    /**
     * 最后登录时间
     */
    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;

    // 实体方法
    
    /**
     * 检查用户是否激活
     */
    public boolean isActive() {
        return status == UserStatus.ACTIVE;
    }

    /**
     * 更新最后登录时间
     */
    public void updateLastLoginTime() {
        this.lastLoginAt = LocalDateTime.now();
        this.setUpdatedAt(LocalDateTime.now());
    }

    /**
     * 禁用用户
     */
    public void disable() {
        this.status = UserStatus.INACTIVE;
        this.setUpdatedAt(LocalDateTime.now());
    }
}

/**
 * 用户状态枚举
 */
public enum UserStatus {
    /**
     * 激活状态
     */
    ACTIVE("active", "激活"),
    
    /**
     * 非激活状态
     */
    INACTIVE("inactive", "非激活"),
    
    /**
     * 暂停状态
     */
    SUSPENDED("suspended", "暂停");

    private final String code;
    private final String description;

    UserStatus(String code, String description) {
        this.code = code;
        this.description = description;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}
```

### 2. 异常处理规范

#### 全局异常处理器
```java
/**
 * 全局异常处理器
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 业务异常处理
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        log.warn("业务异常: {}", e.getMessage());
        
        ErrorResponse response = ErrorResponse.builder()
            .code(e.getErrorCode().getCode())
            .message(e.getMessage())
            .timestamp(System.currentTimeMillis())
            .build();
            
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    /**
     * 资源不存在异常处理
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException e) {
        log.warn("资源不存在: {}", e.getMessage());
        
        ErrorResponse response = ErrorResponse.builder()
            .code(ErrorCode.RESOURCE_NOT_FOUND.getCode())
            .message(e.getMessage())
            .timestamp(System.currentTimeMillis())
            .build();
            
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    /**
     * 参数验证异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        log.warn("参数验证失败: {}", e.getMessage());
        
        List<String> errors = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.toList());
            
        ErrorResponse response = ErrorResponse.builder()
            .code(ErrorCode.VALIDATION_FAILED.getCode())
            .message("参数验证失败")
            .details(errors)
            .timestamp(System.currentTimeMillis())
            .build();
            
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    /**
     * 系统异常处理
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleSystemException(Exception e) {
        log.error("系统异常", e);
        
        ErrorResponse response = ErrorResponse.builder()
            .code(ErrorCode.SYSTEM_ERROR.getCode())
            .message("系统内部错误")
            .timestamp(System.currentTimeMillis())
            .build();
            
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}

/**
 * 业务异常
 */
public class BusinessException extends RuntimeException {
    
    private final ErrorCode errorCode;
    
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
    
    public BusinessException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public ErrorCode getErrorCode() {
        return errorCode;
    }
}

/**
 * 错误码枚举
 */
@Getter
public enum ErrorCode {
    
    // 通用错误
    SUCCESS(200, "操作成功"),
    SYSTEM_ERROR(500, "系统内部错误"),
    VALIDATION_FAILED(400, "参数验证失败"),
    RESOURCE_NOT_FOUND(404, "资源不存在"),
    UNAUTHORIZED(401, "未授权访问"),
    FORBIDDEN(403, "无权限访问"),
    
    // 用户相关错误
    USERNAME_ALREADY_EXISTS(10001, "用户名已存在"),
    EMAIL_ALREADY_EXISTS(10002, "邮箱已存在"),
    INVALID_USERNAME_FORMAT(10003, "用户名格式不正确"),
    INVALID_EMAIL_FORMAT(10004, "邮箱格式不正确"),
    WEAK_PASSWORD(10005, "密码强度不足"),
    USER_NOT_FOUND(10006, "用户不存在"),
    USER_DISABLED(10007, "用户已被禁用"),
    
    // 认证相关错误
    INVALID_CREDENTIALS(20001, "用户名或密码错误"),
    TOKEN_EXPIRED(20002, "登录已过期"),
    TOKEN_INVALID(20003, "无效的登录凭证"),
    
    // 项目相关错误
    PROJECT_NOT_FOUND(30001, "项目不存在"),
    PROJECT_ACCESS_DENIED(30002, "无项目访问权限"),
    PROJECT_NAME_EXISTS(30003, "项目名称已存在");
    
    private final int code;
    private final String message;
    
    ErrorCode(int code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

### 3. 配置类规范

#### 数据库配置
```java
/**
 * 数据库配置
 */
@Configuration
@EnableJpaRepositories(basePackages = "com.codivio.userservice.repository")
@EnableTransactionManagement
@Slf4j
public class DatabaseConfig {

    @Value("${spring.datasource.url}")
    private String datasourceUrl;

    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.hikari")
    public HikariDataSource dataSource() {
        log.info("初始化数据源，URL: {}", datasourceUrl);
        return DataSourceBuilder.create()
            .type(HikariDataSource.class)
            .build();
    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    /**
     * 审计配置
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            // 从SecurityContext获取当前用户
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated()) {
                return Optional.of(authentication.getName());
            }
            return Optional.of("system");
        };
    }
}
```

#### Redis配置
```java
/**
 * Redis配置
 */
@Configuration
@EnableCaching
@Slf4j
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // 使用Jackson2JsonRedisSerializer来序列化和反序列化value
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);

        // 设置序列化器
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());

        template.afterPropertiesSet();
        
        log.info("Redis模板配置完成");
        return template;
    }

    /**
     * 缓存管理器
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
```

---

## 📊 数据库规范

### 1. 表设计规范

#### 命名规范
```sql
-- ✅ 表命名：小写字母+下划线
CREATE TABLE users (
    id VARCHAR(32) PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    nickname VARCHAR(100) COMMENT '昵称',
    avatar_url VARCHAR(255) COMMENT '头像地址',
    status TINYINT DEFAULT 1 COMMENT '状态: 0-禁用, 1-正常',
    last_login_at TIMESTAMP NULL COMMENT '最后登录时间',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) COMMENT '用户表';

-- ✅ 外键关系表
CREATE TABLE project_members (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id VARCHAR(32) NOT NULL COMMENT '项目ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    role ENUM('owner', 'editor', 'viewer') DEFAULT 'editor' COMMENT '角色',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '加入时间',
    
    UNIQUE KEY uk_project_user (project_id, user_id),
    INDEX idx_project_id (project_id),
    INDEX idx_user_id (user_id),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT '项目成员表';
```

#### 字段设计规范
```sql
-- ✅ 字段类型选择规范
CREATE TABLE example_table (
    -- 主键：字符串ID使用VARCHAR(32)，数字ID使用BIGINT
    id VARCHAR(32) PRIMARY KEY,
    
    -- 状态字段：使用TINYINT，明确注释每个值的含义
    status TINYINT DEFAULT 1 COMMENT '状态: 0-删除, 1-正常, 2-禁用',
    
    -- 枚举字段：使用ENUM或VARCHAR，明确可选值
    priority ENUM('low', 'medium', 'high') DEFAULT 'medium',
    
    -- 时间字段：统一使用TIMESTAMP，设置默认值和更新策略
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 文本字段：根据长度选择合适类型
    title VARCHAR(255) NOT NULL COMMENT '标题（最多255字符）',
    description TEXT COMMENT '描述（长文本）',
    content LONGTEXT COMMENT '内容（超长文本）',
    
    -- 数值字段：明确精度和范围
    amount DECIMAL(10,2) COMMENT '金额（精确到分）',
    count INT UNSIGNED DEFAULT 0 COMMENT '计数（非负整数）',
    
    -- JSON字段：存储结构化数据
    metadata JSON COMMENT '元数据',
    
    -- 版本字段：用于乐观锁
    version INT DEFAULT 1 COMMENT '版本号'
) COMMENT '示例表';
```

### 2. 索引设计规范

#### 索引策略
```sql
-- ✅ 单列索引
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_user_status ON users(status);
CREATE INDEX idx_created_at ON users(created_at);

-- ✅ 复合索引（注意字段顺序）
-- 最常用的查询条件在前
CREATE INDEX idx_project_status_created ON projects(status, created_at);
CREATE INDEX idx_user_status_type ON users(status, user_type, created_at);

-- ✅ 唯一索引
CREATE UNIQUE INDEX uk_user_username ON users(username);
CREATE UNIQUE INDEX uk_project_name_owner ON projects(name, owner_id);

-- ✅ 前缀索引（用于长字符串字段）
CREATE INDEX idx_file_path_prefix ON project_files(file_path(100));

-- ✅ 函数索引（MySQL 8.0+）
CREATE INDEX idx_user_email_lower ON users((LOWER(email)));

-- ❌ 避免的索引设计
-- 避免在小表上创建过多索引
-- 避免在经常更新的字段上创建索引
-- 避免在选择性差的字段上创建索引（如性别字段）
```

### 3. SQL编写规范

#### 查询优化规范
```sql
-- ✅ 推荐的查询写法
-- 使用明确的字段列表，避免SELECT *
SELECT u.id, u.username, u.email, u.created_at
FROM users u
WHERE u.status = 1
  AND u.created_at >= '2024-01-01'
ORDER BY u.created_at DESC
LIMIT 10;

-- ✅ 使用适当的JOIN
SELECT 
    p.id,
    p.name,
    u.username AS owner_name,
    COUNT(pm.user_id) AS member_count
FROM projects p
INNER JOIN users u ON p.owner_id = u.id
LEFT JOIN project_members pm ON p.id = pm.project_id
WHERE p.status = 1
GROUP BY p.id, p.name, u.username
HAVING member_count > 0
ORDER BY p.created_at DESC;

-- ✅ 使用EXISTS而不是IN（当子查询返回大量数据时）
SELECT u.id, u.username
FROM users u
WHERE EXISTS (
    SELECT 1 
    FROM project_members pm 
    WHERE pm.user_id = u.id
);

-- ✅ 使用UNION ALL而不是UNION（当不需要去重时）
SELECT 'user' AS type, id, username AS name FROM users
UNION ALL
SELECT 'project' AS type, id, name FROM projects;

-- ❌ 避免的查询写法
-- 避免SELECT *
SELECT * FROM users;

-- 避免不必要的子查询
SELECT u.* FROM users u
WHERE u.id IN (
    SELECT DISTINCT pm.user_id 
    FROM project_members pm
);

-- 避免在WHERE子句中使用函数
SELECT * FROM users 
WHERE YEAR(created_at) = 2024;  -- 应该使用范围查询

-- 正确写法
SELECT * FROM users 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';
```

---

## 🔒 安全规范

### 1. 认证授权规范

#### JWT实现规范
```java
/**
 * JWT工具类
 */
@Component
@Slf4j
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration:86400}")
    private Long expiration;

    /**
     * 生成JWT Token
     */
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userDetails.getUserId());
        claims.put("username", userDetails.getUsername());
        claims.put("authorities", userDetails.getAuthorities());
        
        return createToken(claims, userDetails.getUsername());
    }

    /**
     * 创建Token
     */
    private String createToken(Map<String, Object> claims, String subject) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration * 1000);

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS256, secret)
            .compact();
    }

    /**
     * 验证Token
     */
    public boolean validateToken(String token) {
        try {
            // 检查是否在黑名单中
            if (isTokenBlacklisted(token)) {
                return false;
            }
            
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.warn("JWT验证失败: {}", e.getMessage());
            return false;
        }
    }

    /**
     * 检查Token是否在黑名单中
     */
    private boolean isTokenBlacklisted(String token) {
        String tokenId = getTokenId(token);
        return redisTemplate.hasKey("jwt:blacklist:" + tokenId);
    }

    /**
     * 将Token加入黑名单
     */
    public void blacklistToken(String token) {
        String tokenId = getTokenId(token);
        Date expiration = getExpirationDateFromToken(token);
        
        if (expiration.after(new Date())) {
            Duration ttl = Duration.between(Instant.now(), expiration.toInstant());
            redisTemplate.opsForValue().set("jwt:blacklist:" + tokenId, true, ttl);
        }
    }
}
```

#### 权限控制规范
```java
/**
 * 安全配置
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtRequestFilter jwtRequestFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authz -> authz
                // 公开端点
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // 需要认证的端点
                .requestMatchers(HttpMethod.GET, "/api/v1/users/me").authenticated()
                .requestMatchers(HttpMethod.PUT, "/api/v1/users/me").authenticated()
                
                // 需要特定权限的端点
                .requestMatchers(HttpMethod.POST, "/api/v1/users").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/v1/users/**").hasRole("ADMIN")
                
                // 其他请求都需要认证
                .anyRequest().authenticated()
            )
            .exceptionHandling()
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .and()
            .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

/**
 * 权限注解使用示例
 */
@Service
public class ProjectService {

    @PreAuthorize("hasRole('ADMIN') or @projectService.isOwner(#projectId, authentication.name)")
    public void deleteProject(String projectId) {
        // 删除项目逻辑
    }

    @PreAuthorize("@projectService.hasAccess(#projectId, authentication.name, 'READ')")
    public Project getProject(String projectId) {
        // 获取项目逻辑
    }

    @PostAuthorize("@projectService.filterSensitiveData(returnObject, authentication.name)")
    public Project getProjectWithSensitiveData(String projectId) {
        // 获取包含敏感数据的项目信息
    }

    public boolean isOwner(String projectId, String username) {
        // 检查是否为项目所有者
    }

    public boolean hasAccess(String projectId, String username, String permission) {
        // 检查用户是否有特定权限
    }
}
```

### 2. 输入验证规范

#### 参数验证
```java
/**
 * 请求参数验证
 */
@Data
@Valid
public class CreateUserRequest {

    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过100个字符")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Size(min = 8, max = 50, message = "密码长度必须在8-50个字符之间")
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$",
        message = "密码必须包含至少一个大写字母、一个小写字母、一个数字和一个特殊字符"
    )
    private String password;

    @Size(max = 50, message = "昵称不能超过50个字符")
    @Pattern(regexp = "^[\\u4e00-\\u9fa5a-zA-Z0-9_\\s]*$", message = "昵称只能包含中文、字母、数字、下划线和空格")
    private String nickname;

    @URL(message = "头像URL格式不正确")
    private String avatarUrl;

    /**
     * 自定义验证方法
     */
    @AssertTrue(message = "用户名不能与昵称相同")
    public boolean isUsernameAndNicknameDifferent() {
        if (nickname == null || nickname.trim().isEmpty()) {
            return true;
        }
        return !username.equals(nickname.trim());
    }
}

/**
 * 自定义验证注解
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = StrongPasswordValidator.class)
@Documented
public @interface StrongPassword {
    String message() default "密码强度不足";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

/**
 * 密码强度验证器
 */
public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {

    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;
        }

        // 检查密码长度
        if (password.length() < 8) {
            return false;
        }

        // 检查是否包含大写字母
        if (!password.matches(".*[A-Z].*")) {
            return false;
        }

        // 检查是否包含小写字母
        if (!password.matches(".*[a-z].*")) {
            return false;
        }

        // 检查是否包含数字
        if (!password.matches(".*[0-9].*")) {
            return false;
        }

        // 检查是否包含特殊字符
        if (!password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?].*")) {
            return false;
        }

        // 检查是否包含常见弱密码
        String[] weakPasswords = {"password", "123456", "qwerty", "admin"};
        String lowerPassword = password.toLowerCase();
        for (String weak : weakPasswords) {
            if (lowerPassword.contains(weak)) {
                return false;
            }
        }

        return true;
    }
}
```

### 3. SQL注入防护

#### MyBatis安全使用
```xml
<!-- ✅ 推荐：使用#{}参数绑定防止SQL注入 -->
<select id="findUsersByCondition" resultType="User">
    SELECT id, username, email, created_at
    FROM users
    WHERE status = #{status}
    <if test="keyword != null and keyword != ''">
        AND (username LIKE CONCAT('%', #{keyword}, '%') 
             OR email LIKE CONCAT('%', #{keyword}, '%'))
    </if>
    <if test="startDate != null">
        AND created_at >= #{startDate}
    </if>
    <if test="endDate != null">
        AND created_at &lt;= #{endDate}
    </if>
    ORDER BY 
    <choose>
        <when test="sortField == 'username'">username</when>
        <when test="sortField == 'email'">email</when>
        <when test="sortField == 'created_at'">created_at</when>
        <otherwise>id</otherwise>
    </choose>
    <if test="sortOrder == 'desc'">DESC</if>
    LIMIT #{offset}, #{limit}
</select>

<!-- ❌ 危险：使用${}容易导致SQL注入 -->
<select id="badExample" resultType="User">
    SELECT * FROM users 
    WHERE username = '${username}'  <!-- 危险！ -->
    ORDER BY ${sortField}           <!-- 危险！ -->
</select>

<!-- ✅ 如果必须使用${}，确保参数经过严格验证 -->
<select id="dynamicOrderBy" resultType="User">
    SELECT id, username, email 
    FROM users 
    WHERE status = #{status}
    ORDER BY 
    <choose>
        <when test="sortField == 'username'">username</when>
        <when test="sortField == 'email'">email</when>
        <when test="sortField == 'created_at'">created_at</when>
        <otherwise>id</otherwise>
    </choose>
    ${sortOrder}  <!-- 仅在严格验证后使用 -->
</select>
```

---

## 📋 日志规范

### 1. 日志级别使用

#### 日志级别定义
```java
/**
 * 日志使用示例
 */
@Service
@Slf4j
public class UserService {

    /**
     * ERROR：记录错误信息，需要立即关注
     */
    public User createUser(CreateUserRequest request) {
        try {
            // 业务逻辑
            return userRepository.save(user);
        } catch (DataIntegrityViolationException e) {
            log.error("创建用户失败，数据完整性错误: {}, 请求: {}", e.getMessage(), request, e);
            throw new BusinessException(ErrorCode.USER_CREATION_FAILED);
        } catch (Exception e) {
            log.error("创建用户时发生未知错误: {}", e.getMessage(), e);
            throw new SystemException("用户创建失败");
        }
    }

    /**
     * WARN：记录警告信息，可能的问题
     */
    public void updateUserLastLogin(String userId) {
        try {
            User user = userRepository.findById(userId).orElse(null);
            if (user == null) {
                log.warn("更新最后登录时间失败，用户不存在: {}", userId);
                return;
            }
            
            if (user.getStatus() == UserStatus.INACTIVE) {
                log.warn("非活跃用户尝试登录: {}", userId);
            }
            
            user.updateLastLoginTime();
            userRepository.save(user);
        } catch (Exception e) {
            log.warn("更新用户最后登录时间失败: {}, 错误: {}", userId, e.getMessage());
        }
    }

    /**
     * INFO：记录重要的业务流程信息
     */
    public void deleteUser(String userId) {
        log.info("开始删除用户: {}", userId);
        
        User user = getUserById(userId);
        
        // 检查用户是否有关联数据
        long projectCount = projectRepository.countByOwnerId(userId);
        if (projectCount > 0) {
            log.info("用户{}拥有{}个项目，需要先处理关联数据", userId, projectCount);
            throw new BusinessException(ErrorCode.USER_HAS_ASSOCIATED_DATA);
        }
        
        userRepository.delete(user);
        
        // 清除缓存
        cacheManager.evict("users", userId);
        
        log.info("用户删除成功: {}", userId);
    }

    /**
     * DEBUG：记录详细的调试信息
     */
    public List<User> searchUsers(UserSearchCriteria criteria) {
        log.debug("搜索用户，条件: {}", criteria);
        
        Specification<User> spec = UserSpecifications.build(criteria);
        log.debug("构建的查询规格: {}", spec);
        
        List<User> users = userRepository.findAll(spec);
        log.debug("搜索结果数量: {}", users.size());
        
        return users;
    }

    /**
     * TRACE：记录最详细的执行轨迹
     */
    @Cacheable(value = "users", key = "#userId")
    public User getUserById(String userId) {
        log.trace("进入getUserById方法，参数: {}", userId);
        
        if (userId == null || userId.trim().isEmpty()) {
            log.trace("用户ID为空，抛出参数异常");
            throw new IllegalArgumentException("用户ID不能为空");
        }
        
        log.trace("从数据库查询用户: {}", userId);
        Optional<User> userOpt = userRepository.findById(userId);
        
        if (userOpt.isPresent()) {
            User user = userOpt.get();
            log.trace("用户查询成功: {}", user.getUsername());
            return user;
        } else {
            log.trace("用户不存在: {}", userId);
            throw new ResourceNotFoundException("用户不存在: " + userId);
        }
    }
}
```

### 2. 结构化日志

#### Logback配置
```xml
<!-- logback-spring.xml -->
<configuration>
    <!-- 开发环境配置 -->
    <springProfile name="dev">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{36}:%line] - %msg%n</pattern>
            </encoder>
        </appender>
        
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>

    <!-- 生产环境配置 -->
    <springProfile name="prod">
        <!-- JSON格式日志 -->
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/application.log</file>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <pattern>
                        <pattern>
                            {
                                "service": "user-service",
                                "version": "@project.version@",
                                "environment": "${spring.profiles.active}",
                                "hostname": "${HOSTNAME:-unknown}",
                                "trace_id": "%X{traceId:-}",
                                "span_id": "%X{spanId:-}",
                                "user_id": "%X{userId:-}",
                                "request_id": "%X{requestId:-}"
                            }
                        </pattern>
                    </pattern>
                </providers>
            </encoder>
            
            <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>10GB</totalSizeCap>
            </rollingPolicy>
        </appender>

        <!-- 错误日志单独文件 -->
        <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/error.log</file>
            <filter class="ch.qos.logback.classic.filter.LevelFilter">
                <level>ERROR</level>
                <onMatch>ACCEPT</onMatch>
                <onMismatch>DENY</onMismatch>
            </filter>
            
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <stackTrace/>
                    <mdc/>
                </providers>
            </encoder>
            
            <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                <fileNamePattern>logs/error.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
                <maxFileSize>50MB</maxFileSize>
                <maxHistory>90</maxHistory>
            </rollingPolicy>
        </appender>

        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
    </springProfile>

    <!-- 特定包的日志级别 -->
    <logger name="com.codivio" level="DEBUG" additivity="false">
        <appender-ref ref="FILE"/>
    </logger>
    
    <logger name="org.springframework.security" level="DEBUG"/>
    <logger name="org.springframework.web" level="DEBUG"/>
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.type" level="TRACE"/>
</configuration>
```

### 3. 操作审计日志

#### 审计日志实现
```java
/**
 * 操作审计注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AuditLog {
    
    /**
     * 操作类型
     */
    String operation();
    
    /**
     * 资源类型
     */
    String resourceType() default "";
    
    /**
     * 是否记录请求参数
     */
    boolean logParams() default true;
    
    /**
     * 是否记录响应结果
     */
    boolean logResult() default false;
    
    /**
     * 敏感字段（需要脱敏）
     */
    String[] sensitiveFields() default {"password", "token", "secret"};
}

/**
 * 审计日志切面
 */
@Aspect
@Component
@Slf4j
public class AuditLogAspect {

    private final AuditLogService auditLogService;
    private final ObjectMapper objectMapper;

    @Around("@annotation(auditLog)")
    public Object around(ProceedingJoinPoint point, AuditLog auditLog) throws Throwable {
        String requestId = UUID.randomUUID().toString();
        String userId = getCurrentUserId();
        String username = getCurrentUsername();
        String ipAddress = getClientIpAddress();
        String userAgent = getCurrentUserAgent();
        
        // 方法信息
        String className = point.getTarget().getClass().getSimpleName();
        String methodName = point.getSignature().getName();
        String fullMethodName = className + "." + methodName;
        
        // 请求参数
        Object[] args = point.getArgs();
        String requestParams = auditLog.logParams() ? 
            maskSensitiveData(objectMapper.writeValueAsString(args), auditLog.sensitiveFields()) : 
            null;
        
        Instant startTime = Instant.now();
        Object result = null;
        String errorMessage = null;
        boolean success = true;
        
        try {
            log.info("开始执行操作: {}, 用户: {}, 请求ID: {}", auditLog.operation(), username, requestId);
            
            result = point.proceed();
            
            log.info("操作执行成功: {}, 用户: {}, 耗时: {}ms", 
                auditLog.operation(), username, 
                Duration.between(startTime, Instant.now()).toMillis());
            
            return result;
            
        } catch (Exception e) {
            success = false;
            errorMessage = e.getMessage();
            
            log.error("操作执行失败: {}, 用户: {}, 错误: {}", 
                auditLog.operation(), username, e.getMessage(), e);
            
            throw e;
            
        } finally {
            // 记录审计日志
            try {
                AuditLogEntry entry = AuditLogEntry.builder()
                    .requestId(requestId)
                    .userId(userId)
                    .username(username)
                    .operation(auditLog.operation())
                    .resourceType(auditLog.resourceType())
                    .methodName(fullMethodName)
                    .requestParams(requestParams)
                    .responseData(auditLog.logResult() && success ? 
                        maskSensitiveData(objectMapper.writeValueAsString(result), auditLog.sensitiveFields()) : 
                        null)
                    .success(success)
                    .errorMessage(errorMessage)
                    .ipAddress(ipAddress)
                    .userAgent(userAgent)
                    .executionTime(Duration.between(startTime, Instant.now()).toMillis())
                    .timestamp(Instant.now())
                    .build();
                
                auditLogService.saveAuditLog(entry);
                
            } catch (Exception e) {
                log.error("保存审计日志失败: {}", e.getMessage(), e);
            }
        }
    }

    /**
     * 脱敏敏感数据
     */
    private String maskSensitiveData(String data, String[] sensitiveFields) {
        if (data == null || sensitiveFields.length == 0) {
            return data;
        }
        
        try {
            JsonNode jsonNode = objectMapper.readTree(data);
            maskJsonNode(jsonNode, sensitiveFields);
            return objectMapper.writeValueAsString(jsonNode);
        } catch (Exception e) {
            log.warn("数据脱敏失败: {}", e.getMessage());
            return data;
        }
    }

    private void maskJsonNode(JsonNode node, String[] sensitiveFields) {
        if (node.isObject()) {
            ObjectNode objectNode = (ObjectNode) node;
            for (String field : sensitiveFields) {
                if (objectNode.has(field)) {
                    objectNode.put(field, "***");
                }
            }
            
            objectNode.fields().forEachRemaining(entry -> 
                maskJsonNode(entry.getValue(), sensitiveFields));
        } else if (node.isArray()) {
            for (JsonNode item : node) {
                maskJsonNode(item, sensitiveFields);
            }
        }
    }
}

/**
 * 使用示例
 */
@Service
public class UserService {

    @AuditLog(
        operation = "CREATE_USER",
        resourceType = "USER",
        logParams = true,
        logResult = true,
        sensitiveFields = {"password", "passwordHash"}
    )
    public UserDTO createUser(CreateUserRequest request) {
        // 业务逻辑
    }

    @AuditLog(
        operation = "DELETE_USER",
        resourceType = "USER",
        logParams = true
    )
    public void deleteUser(String userId) {
        // 业务逻辑
    }

    @AuditLog(
        operation = "LOGIN",
        resourceType = "AUTH",
        logParams = true,
        sensitiveFields = {"password"}
    )
    public LoginResponse login(LoginRequest request) {
        // 业务逻辑
    }
}
```

---

## 🎯 性能规范

### 1. 数据库性能优化

#### 查询优化规范
```java
/**
 * Repository性能优化示例
 */
@Repository
public interface UserRepository extends JpaRepository<User, String> {

    // ✅ 使用索引字段查询
    @Query("SELECT u FROM User u WHERE u.username = :username AND u.status = :status")
    Optional<User> findByUsernameAndStatus(@Param("username") String username, 
                                          @Param("status") UserStatus status);

    // ✅ 分页查询，避免查询大量数据
    @Query("SELECT u FROM User u WHERE u.createdAt >= :startDate ORDER BY u.createdAt DESC")
    Page<User> findRecentUsers(@Param("startDate") LocalDateTime startDate, Pageable pageable);

    // ✅ 只查询需要的字段
    @Query("SELECT new com.codivio.dto.UserSummaryDTO(u.id, u.username, u.email) " +
           "FROM User u WHERE u.status = :status")
    List<UserSummaryDTO> findUserSummaries(@Param("status") UserStatus status);

    // ✅ 使用批量操作
    @Modifying
    @Query("UPDATE User u SET u.lastLoginAt = :loginTime WHERE u.id IN :userIds")
    int updateLastLoginBatch(@Param("userIds") List<String> userIds, 
                            @Param("loginTime") LocalDateTime loginTime);

    // ✅ 使用EXISTS而不是COUNT
    @Query("SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END " +
           "FROM User u WHERE u.email = :email")
    boolean existsByEmail(@Param("email") String email);

    // ❌ 避免N+1查询问题
    // 错误：会导致N+1查询
    // List<User> findByStatus(UserStatus status);  // 然后在业务代码中访问user.getProjects()

    // ✅ 正确：使用JOIN FETCH
    @Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.projects WHERE u.status = :status")
    List<User> findByStatusWithProjects(@Param("status") UserStatus status);
}

/**
 * 缓存优化
 */
@Service
@CacheConfig(cacheNames = "users")
public class UserService {

    // ✅ 缓存单个实体
    @Cacheable(key = "#userId")
    public UserDTO getUserById(String userId) {
        // 实现
    }

    // ✅ 缓存查询结果
    @Cacheable(key = "#status.name() + '_' + #pageable.pageNumber + '_' + #pageable.pageSize")
    public Page<UserDTO> getUsersByStatus(UserStatus status, Pageable pageable) {
        // 实现
    }

    // ✅ 更新时清除缓存
    @CacheEvict(key = "#userId")
    public UserDTO updateUser(String userId, UpdateUserRequest request) {
        // 实现
    }

    // ✅ 删除时清除相关缓存
    @CacheEvict(allEntries = true)
    public void deleteUser(String userId) {
        // 实现
    }

    // ✅ 条件缓存
    @Cacheable(key = "#userId", condition = "#userId != null", unless = "#result == null")
    public UserDTO getUserIfExists(String userId) {
        // 实现
    }
}
```

### 2. 接口性能优化

#### 响应时间优化
```java
/**
 * 异步处理优化
 */
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    // ✅ 异步处理耗时操作
    @PostMapping("/{userId}/export")
    public ResponseEntity<AsyncTaskResponse> exportUserData(@PathVariable String userId) {
        String taskId = UUID.randomUUID().toString();
        
        // 异步执行导出任务
        CompletableFuture.runAsync(() -> {
            try {
                userExportService.exportUserData(userId, taskId);
            } catch (Exception e) {
                log.error("用户数据导出失败: {}", e.getMessage(), e);
                taskService.markTaskFailed(taskId, e.getMessage());
            }
        });
        
        return ResponseEntity.accepted()
            .body(new AsyncTaskResponse(taskId, "数据导出任务已启动"));
    }

    // ✅ 批量操作优化
    @PostMapping("/batch")
    public ResponseEntity<BatchOperationResponse> batchCreateUsers(
            @RequestBody @Valid List<CreateUserRequest> requests) {
        
        if (requests.size() > 100) {
            throw new BusinessException(ErrorCode.BATCH_SIZE_EXCEEDED);
        }
        
        BatchOperationResponse response = userService.batchCreateUsers(requests);
        return ResponseEntity.ok(response);
    }

    // ✅ 流式响应大量数据
    @GetMapping("/export/stream")
    public ResponseEntity<StreamingResponseBody> streamUsers(
            @RequestParam(defaultValue = "active") String status) {
        
        StreamingResponseBody stream = output -> {
            try (JsonGenerator generator = objectMapper.getFactory().createGenerator(output)) {
                generator.writeStartArray();
                
                userService.streamUsersByStatus(UserStatus.valueOf(status.toUpperCase()), user -> {
                    try {
                        generator.writeObject(user);
                        generator.flush();
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                });
                
                generator.writeEndArray();
            }
        };
        
        return ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .body(stream);
    }
}

/**
 * 连接池优化
 */
@Configuration
public class PerformanceConfig {

    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.hikari")
    public HikariDataSource dataSource() {
        HikariConfig config = new HikariConfig();
        
        // 连接池大小优化
        config.setMaximumPoolSize(20);  // 最大连接数
        config.setMinimumIdle(5);       // 最小空闲连接数
        config.setConnectionTimeout(30000);      // 连接超时30秒
        config.setIdleTimeout(600000);           // 空闲超时10分钟
        config.setMaxLifetime(1800000);          // 连接最大生命周期30分钟
        config.setLeakDetectionThreshold(60000); // 连接泄漏检测1分钟
        
        // 性能优化参数
        config.setReadOnly(false);
        config.setAutoCommit(true);
        config.setTransactionIsolation("TRANSACTION_READ_COMMITTED");
        
        return new HikariDataSource(config);
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 使用高效的序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        // 启用事务支持
        template.setEnableTransactionSupport(true);
        
        return template;
    }

    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

---

## 🎯 面试准备要点

### 💡 开发规范亮点

1. **代码质量保证** - 完整的编码规范和最佳实践
2. **安全性考虑** - 全面的安全防护措施
3. **性能优化** - 数据库、缓存、接口多层次优化
4. **可维护性** - 清晰的代码结构和文档规范
5. **团队协作** - 统一的开发流程和质量标准

### 🎯 常见面试问题

#### 1. "如何保证代码质量？"
```yaml
回答要点:
  - 编码规范和最佳实践
  - 代码审查机制
  - 单元测试和集成测试
  - 静态代码分析工具
  - 持续集成和自动化检查
```

#### 2. "如何处理系统安全问题？"
```yaml
回答要点:
  - 输入验证和参数检查
  - SQL注入防护
  - XSS和CSRF防护
  - 认证授权机制
  - 敏感数据加密存储
```

#### 3. "如何优化系统性能？"
```yaml
回答要点:
  - 数据库查询优化
  - 缓存策略设计
  - 异步处理机制
  - 连接池优化配置
  - 批量操作减少IO
```

#### 4. "如何保证系统可维护性？"
```yaml
回答要点:
  - 清晰的代码结构和命名
  - 完善的文档和注释
  - 统一的错误处理机制
  - 结构化的日志记录
  - 模块化的系统设计
```