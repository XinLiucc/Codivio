# Codivio 部署运维指南

## 🎯 部署策略

本指南专注于**Docker Compose**本地开发和简单生产部署，避免过度复杂的Kubernetes配置，确保快速上手和演示。

### 部署模式
- 🐳 **开发环境** - Docker Compose + 热重载
- 🚀 **生产环境** - Docker Compose + Nginx反向代理
- 📦 **一键部署** - 自动化脚本 + 环境检查

## 📦 Docker 容器化

### 项目结构
```
codivio/
├── docker-compose.yml          # 核心编排文件
├── docker-compose.prod.yml     # 生产环境配置
├── .env                        # 环境变量配置
├── nginx/
│   └── nginx.conf              # Nginx配置
├── scripts/
│   ├── deploy.sh               # 一键部署脚本
│   ├── backup.sh               # 数据备份脚本
│   └── health-check.sh         # 健康检查脚本
├── user-service/
│   └── Dockerfile
├── project-service/
│   └── Dockerfile
├── collaboration-service/
│   └── Dockerfile
├── gateway-service/
│   └── Dockerfile
└── frontend/
    └── Dockerfile
```

---

## 🐳 Docker Compose 配置

### 开发环境配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # ===== 微服务 =====
  user-service:
    build: 
      context: ./user-service
      dockerfile: Dockerfile
    ports:
      - "8081:8081"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - MYSQL_HOST=mysql
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - mysql
      - redis
      - rabbitmq
    volumes:
      - ./logs/user-service:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  project-service:
    build: 
      context: ./project-service
      dockerfile: Dockerfile
    ports:
      - "8082:8082"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - MYSQL_HOST=mysql
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - mysql
      - redis
      - rabbitmq
    volumes:
      - ./logs/project-service:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8082/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  collaboration-service:
    build: 
      context: ./collaboration-service
      dockerfile: Dockerfile
    ports:
      - "8083:8083"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - redis
      - rabbitmq
    volumes:
      - ./logs/collaboration-service:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8083/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  gateway-service:
    build: 
      context: ./gateway-service
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - REDIS_HOST=redis
    depends_on:
      - user-service
      - project-service
      - collaboration-service
    volumes:
      - ./logs/gateway-service:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend:
    build: 
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    depends_on:
      - gateway-service
    restart: unless-stopped

  # ===== 基础设施 =====
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-codivio_root_2024}
      MYSQL_DATABASE: codivio
      MYSQL_USER: ${MYSQL_USER:-codivio}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-codivio_2024}
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/init:/docker-entrypoint-initdb.d
    command: --default-authentication-plugin=mysql_native_password
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD}"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-codivio_redis_2024}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  rabbitmq:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672:5672"
      - "15672:15672"  # 管理界面
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER:-codivio}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD:-codivio_mq_2024}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ===== 反向代理 =====
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - frontend
      - gateway-service
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
  rabbitmq_data:
```

### 环境变量配置
```bash
# .env
# MySQL配置
MYSQL_ROOT_PASSWORD=codivio_root_2024
MYSQL_USER=codivio
MYSQL_PASSWORD=codivio_2024

# Redis配置
REDIS_PASSWORD=codivio_redis_2024

# RabbitMQ配置
RABBITMQ_USER=codivio
RABBITMQ_PASSWORD=codivio_mq_2024

# JWT配置
JWT_SECRET=my_super_secret_key_for_codivio_project_2024

# 应用配置
SPRING_PROFILES_ACTIVE=docker
LOG_LEVEL=INFO
```

---

## 🏗️ Dockerfile 配置

### 后端服务 Dockerfile
```dockerfile
# user-service/Dockerfile
FROM openjdk:17-jdk-alpine AS builder

WORKDIR /app
COPY .mvn/ .mvn
COPY mvnw pom.xml ./
RUN ./mvnw dependency:go-offline

COPY src ./src
RUN ./mvnw clean package -DskipTests

FROM openjdk:17-jre-alpine

# 安装curl用于健康检查
RUN apk add --no-cache curl

# 创建应用用户
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

WORKDIR /app
RUN chown -R appuser:appgroup /app

# 复制应用JAR
COPY --from=builder /app/target/*.jar app.jar

# 创建日志目录
RUN mkdir -p /app/logs && chown -R appuser:appgroup /app/logs

# 切换到非root用户
USER appuser

EXPOSE 8081

# 启动参数优化
ENTRYPOINT ["java", \
  "-server", \
  "-Xms512m", \
  "-Xmx1g", \
  "-XX:+UseG1GC", \
  "-XX:+UseStringDeduplication", \
  "-Djava.awt.headless=true", \
  "-jar", \
  "app.jar"]
```

### 前端 Dockerfile
```dockerfile
# frontend/Dockerfile
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package.json和锁文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码并构建
COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 添加健康检查
RUN apk add --no-cache curl
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost || exit 1

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

---

## 🌐 Nginx 配置

### nginx.conf
```nginx
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    # 基础配置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    client_max_body_size 50M;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    upstream backend {
        server gateway-service:8080;
    }

    server {
        listen 80;
        server_name localhost;

        # 前端静态资源
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;

            # 缓存静态资源
            location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }

        # API请求代理到网关
        location /api/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 超时配置
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

        # WebSocket代理
        location /ws/ {
            proxy_pass http://collaboration-service:8083;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket超时配置
            proxy_connect_timeout 7d;
            proxy_send_timeout 7d;
            proxy_read_timeout 7d;
        }

        # 健康检查端点
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
```

---

## 🚀 一键部署脚本

### deploy.sh
```bash
#!/bin/bash

# Codivio 一键部署脚本
set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 打印日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查依赖
check_dependencies() {
    log_info "检查系统依赖..."
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker 未安装，请先安装 Docker"
        exit 1
    fi
    
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose 未安装，请先安装 Docker Compose"
        exit 1
    fi
    
    log_info "依赖检查通过"
}

# 创建必要目录
create_directories() {
    log_info "创建必要目录..."
    
    mkdir -p logs/{user-service,project-service,collaboration-service,gateway-service}
    mkdir -p database/init
    mkdir -p nginx
    
    log_info "目录创建完成"
}

# 生成配置文件
generate_configs() {
    log_info "生成配置文件..."
    
    # 检查.env文件是否存在
    if [ ! -f ".env" ]; then
        log_warn ".env文件不存在，使用默认配置"
        cp .env.example .env
    fi
    
    log_info "配置文件检查完成"
}

# 拉取镜像
pull_images() {
    log_info "拉取基础镜像..."
    
    docker-compose pull mysql redis rabbitmq nginx
    
    log_info "镜像拉取完成"
}

# 构建应用镜像
build_images() {
    log_info "构建应用镜像..."
    
    docker-compose build --parallel
    
    log_info "镜像构建完成"
}

# 启动服务
start_services() {
    log_info "启动服务..."
    
    # 先启动基础设施
    docker-compose up -d mysql redis rabbitmq
    
    # 等待基础设施就绪
    log_info "等待基础设施启动..."
    sleep 30
    
    # 启动应用服务
    docker-compose up -d
    
    log_info "所有服务启动完成"
}

# 健康检查
health_check() {
    log_info "执行健康检查..."
    
    # 等待服务启动
    sleep 30
    
    # 检查服务状态
    services=("mysql" "redis" "rabbitmq" "user-service" "project-service" "collaboration-service" "gateway-service" "frontend")
    
    for service in "${services[@]}"; do
        if docker-compose ps "$service" | grep -q "Up"; then
            log_info "$service 服务运行正常"
        else
            log_error "$service 服务启动失败"
            docker-compose logs "$service"
        fi
    done
    
    # 检查HTTP端点
    if curl -f http://localhost:80/health > /dev/null 2>&1; then
        log_info "HTTP健康检查通过"
    else
        log_warn "HTTP健康检查失败，但服务可能仍在启动中"
    fi
}

# 显示访问信息
show_info() {
    log_info "部署完成！"
    echo ""
    echo "🎉 Codivio 已成功部署！"
    echo ""
    echo "📍 访问地址："
    echo "   前端应用: http://localhost"
    echo "   API网关: http://localhost/api"
    echo "   RabbitMQ管理: http://localhost:15672"
    echo ""
    echo "🔧 管理命令："
    echo "   查看日志: docker-compose logs -f [service-name]"
    echo "   停止服务: docker-compose down"
    echo "   重启服务: docker-compose restart [service-name]"
    echo ""
    echo "📊 监控命令："
    echo "   服务状态: docker-compose ps"
    echo "   资源使用: docker stats"
    echo ""
}

# 主函数
main() {
    log_info "开始部署 Codivio..."
    
    check_dependencies
    create_directories
    generate_configs
    pull_images
    build_images
    start_services
    health_check
    show_info
    
    log_info "部署完成！"
}

# 执行主函数
main "$@"
```

### 快速启动脚本
```bash
# scripts/start.sh
#!/bin/bash

echo "🚀 启动 Codivio 开发环境..."

# 启动基础设施
docker-compose up -d mysql redis rabbitmq

echo "⏳ 等待基础设施就绪..."
sleep 10

# 启动应用服务
docker-compose up -d

echo "✅ Codivio 启动完成！"
echo "📍 访问地址: http://localhost"
```

### 停止脚本
```bash
# scripts/stop.sh
#!/bin/bash

echo "🛑 停止 Codivio 服务..."

docker-compose down

echo "✅ 所有服务已停止"
```

---

## 📊 监控和日志

### 日志收集配置
```yaml
# docker-compose.override.yml (可选)
version: '3.8'

services:
  user-service:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  project-service:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  collaboration-service:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

### 健康检查脚本
```bash
#!/bin/bash
# scripts/health-check.sh

echo "🔍 Codivio 健康检查"
echo "===================="

# 检查容器状态
echo "📦 容器状态:"
docker-compose ps

echo ""
echo "🌐 服务连通性:"

# 检查各服务端点
endpoints=(
    "http://localhost:8080/actuator/health:网关服务"
    "http://localhost:8081/actuator/health:用户服务"
    "http://localhost:8082/actuator/health:项目服务"
    "http://localhost:8083/actuator/health:协作服务"
    "http://localhost:80/health:Nginx"
)

for endpoint in "${endpoints[@]}"; do
    url="${endpoint%:*}"
    name="${endpoint#*:}"
    
    if curl -s -f "$url" > /dev/null; then
        echo "✅ $name"
    else
        echo "❌ $name"
    fi
done

echo ""
echo "💾 数据库连接:"
if docker-compose exec -T mysql mysqladmin ping -h localhost -u root -pcodivio_root_2024 > /dev/null 2>&1; then
    echo "✅ MySQL"
else
    echo "❌ MySQL"
fi

if docker-compose exec -T redis redis-cli ping > /dev/null 2>&1; then
    echo "✅ Redis"
else
    echo "❌ Redis"
fi

echo ""
echo "📈 资源使用:"
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
```

### 备份脚本
```bash
#!/bin/bash
# scripts/backup.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="./backups/$DATE"

echo "📦 开始备份 Codivio 数据..."

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 备份MySQL数据
echo "🗄️ 备份 MySQL 数据..."
docker-compose exec -T mysql mysqldump -u root -pcodivio_root_2024 --all-databases > "$BACKUP_DIR/mysql.sql"

# 备份Redis数据
echo "💾 备份 Redis 数据..."
docker-compose exec -T redis redis-cli --rdb /data/dump.rdb
docker cp $(docker-compose ps -q redis):/data/dump.rdb "$BACKUP_DIR/redis.rdb"

# 备份配置文件
echo "⚙️ 备份配置文件..."
cp docker-compose.yml "$BACKUP_DIR/"
cp .env "$BACKUP_DIR/"
cp -r nginx "$BACKUP_DIR/"

# 压缩备份
echo "🗜️ 压缩备份文件..."
tar -czf "backups/codivio_backup_$DATE.tar.gz" -C backups "$DATE"
rm -rf "$BACKUP_DIR"

echo "✅ 备份完成: codivio_backup_$DATE.tar.gz"
```

---

## 🎯 生产环境优化

### 生产环境配置
```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  user-service:
    environment:
      - SPRING_PROFILES_ACTIVE=production
      - JAVA_OPTS=-Xms1g -Xmx2g -XX:+UseG1GC
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'

  mysql:
    command: >
      --default-authentication-plugin=mysql_native_password
      --innodb-buffer-pool-size=1G
      --innodb-log-file-size=256M
      --max-connections=1000
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'

  redis:
    command: >
      redis-server 
      --appendonly yes 
      --requirepass codivio_redis_2024
      --maxmemory 512m
      --maxmemory-policy allkeys-lru
```

### 生产部署脚本
```bash
#!/bin/bash
# scripts/deploy-prod.sh

echo "🚀 部署生产环境..."

# 使用生产配置
export COMPOSE_FILE="docker-compose.yml:docker-compose.prod.yml"

# 拉取最新镜像
docker-compose pull

# 重新构建
docker-compose build

# 滚动更新服务
docker-compose up -d --force-recreate --no-deps

echo "✅ 生产环境部署完成！"
```

---

## 🎯 面试准备要点

### 💡 技术亮点

1. **Docker容器化** - 环境一致性，一键部署
2. **微服务编排** - Docker Compose统一管理多服务
3. **健康检查机制** - 容器和应用双重健康检查
4. **日志管理** - 结构化日志收集和轮转
5. **自动化运维** - 部署、备份、监控脚本化

### 🎯 常见面试问题

#### 1. "为什么选择Docker Compose而不是Kubernetes？"
```yaml
回答要点:
  - 项目规模适中，K8s过于复杂
  - 开发和演示阶段，简单易用更重要
  - 学习成本低，快速上手
  - 本地开发友好，资源占用少
  - 生产环境可以轻松迁移到K8s
```

#### 2. "如何保证服务的高可用性？"
```yaml
回答要点:
  - 健康检查机制，自动重启失败容器
  - 服务依赖管理，确保启动顺序
  - 数据持久化，重启不丢失数据
  - 负载均衡，Nginx反向代理
  - 监控告警，及时发现问题
```

#### 3. "容器化的优势是什么？"
```yaml
回答要点:
  - 环境一致性，开发生产环境统一
  - 快速部署，一键启动所有服务
  - 资源隔离，服务间不会相互影响
  - 弹性扩展，可以轻松水平扩容
  - 版本管理，镜像版本化管理
```

#### 4. "如何处理数据备份和恢复？"
```yaml
回答要点:
  - 定期自动备份数据库和Redis
  - 数据卷持久化，重启不丢失
  - 备份文件压缩存储，节省空间
  - 验证备份完整性，确保可恢复
  - 灾难恢复预案，快速故障恢复
```

### 🚀 扩展优化思考

当面试官问"如何支持更大规模的部署？"

```yaml
容器编排:
  - 迁移到Kubernetes，支持自动扩缩容
  - 服务网格，更好的服务间通信
  - 配置中心，统一配置管理

监控体系:
  - Prometheus + Grafana监控
  - ELK日志分析平台
  - 链路追踪，分布式调用监控

自动化:
  - CI/CD流水线，自动化测试部署
  - GitOps，基于Git的部署管理
  - 蓝绿部署，零停机时间更新
```

**这套部署方案既实用又展现了DevOps实践能力，是面试的强有力加分项！** 🎯